<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Discrete Math Chapter 6 - Induction and Recursion</title>
      <link href="/2024/11/24/Discrete%20Math%20Chapter%206:Induction%20and%20Recursion/"/>
      <url>/2024/11/24/Discrete%20Math%20Chapter%206:Induction%20and%20Recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="Discrete-Math-Chapter-6-Induction-and-Recursion"><a href="#Discrete-Math-Chapter-6-Induction-and-Recursion" class="headerlink" title="Discrete Math Chapter 6 - Induction and Recursion"></a>Discrete Math Chapter 6 - Induction and Recursion</h1><h2 id="Mathematical-Induction"><a href="#Mathematical-Induction" class="headerlink" title="Mathematical Induction"></a>Mathematical Induction</h2><h3 id="Principle-of-Mathematical-Induction"><a href="#Principle-of-Mathematical-Induction" class="headerlink" title="Principle of Mathematical Induction"></a>Principle of Mathematical Induction</h3><p>Let $P(n)$ be a <strong>predicate</strong>. i.e., $P(n)$ is either true or false when $n$ is a specific number.<br><strong>Principle of Mathematical Induction</strong>: To prove that $P(n)$ is true for all positive integers $n \in Z^+$, we complete 2 steps:<br>    <strong>Basic step</strong>: prove $P(1)$ is <strong>true</strong>;<br>    <strong>Inductive step</strong>: prove $\forall k \in Z^+,P(k) \rightarrow P(k+1)$ is <strong>true</strong>.<br>    (“$P(k)$ is ture” is called the <strong>inductive hypothesis</strong> (<strong><em>IH</em></strong>)归纳假设)</p><p><strong>Why this principle is valid?</strong><br>Proof by contradiction: Assume $P(n)$ is false for some integer $n ≥ 1$, then the set $S$ of all positive integer n such that $P(n)$ is false is not empty. Let m be the smallest integer in $S$.<br><strong>Why such m exists?</strong><br>We have $m ≥ 2$ as $P(1)$ is true. However, since $P(m – 1)$ is true and $P(m – 1) → P(m)$ is true, $P(m)$ must be true, contradiction!</p><h3 id="Well-Ordering-Principle"><a href="#Well-Ordering-Principle" class="headerlink" title="Well-Ordering Principle"></a>Well-Ordering Principle</h3><p><strong>Well-Ordering Principle</strong>: every nonempty subset of $Z^+$ has a least/minimum element $\longrightarrow$ this is an <strong>axiom</strong>.<br>This principle is <strong>equivalent</strong> to mathematical induction.</p><p>This also means mathematical induction can be generalized from $Z^+$ to <strong>any well-ordered</strong> set $S$, e.g., $N, {n \in Z | n \geq b}$, etc.</p><h3 id="Another-Form-of-Induction"><a href="#Another-Form-of-Induction" class="headerlink" title="Another Form of Induction"></a>Another Form of Induction</h3><p>Consider another form of mathematical induction as follows:<br><strong>First</strong> suppose that we have a proof that $P(1)$ is true.<br><strong>Next</strong> suppose that we have a proof that $∀k ≥ 1, P(1) ∧ P(2) ∧ ··· ∧ P(k) → P(k + 1)$<br>Then, $P(1) → P(2) P(1) ∧ P(2) → P(3) P(1) ∧ P(2) ∧ P(3) → P(4) …$<br>Iterating gives us a proof of $P(n)$ for all $n$.</p><h3 id="Strong-Induction"><a href="#Strong-Induction" class="headerlink" title="Strong Induction"></a>Strong Induction</h3><p><strong>Second principle of mathematical induction</strong>: To prove that $P(n)$ is true for all positive integers $n$, we complete two steps:<br>    Basis step: prove $P(1)$ is true<br>    Inductive step: prove $∀k ∈ Z+ , P(1) ∧ ··· ∧ P(k) → P(k + 1)$ is true<br>    (here “$P(1) ∧ P(2) ∧ ··· ∧ P(k)$ is true” is the <strong>inductive hypothesis</strong> (IH))</p><p>This is called <strong>strong induction</strong> or <strong>complete induction</strong>, while the previous principle is called <strong>weak</strong> or <strong>incomplete induction</strong>.<br>In practice, strong induction is often <strong>easier</strong> to apply than its weak form, because the inductive hypothesis is stronger.<br>However, these two forms of induction are actually <strong>equivalent</strong>.</p><h3 id="Core-idea"><a href="#Core-idea" class="headerlink" title="Core idea"></a>Core idea</h3><p>The assumption “$P(k)$ is true” <strong>OR</strong> “$P(1) ∧ P(2) ∧ ··· ∧ P(k)$ is true” is called the <strong>inductive hypothesis</strong> (IH).<br>IH is used as <strong>premises</strong> to prove the conclusion “$P(k + 1)$ is true” .</p><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><strong>Recursion</strong>: a method of solving a computational problem where its solution depends on <strong>solutions to smaller instances</strong> of the same problem.<br>Recursive computer programs or algorithms often lead to <strong>inductive analysis</strong>.<br>A classical example of recursion is the <strong>Towers of Hanoi puzzle</strong>.</p><h3 id="Towers-of-Hanoi-Puzzle"><a href="#Towers-of-Hanoi-Puzzle" class="headerlink" title="Towers of Hanoi Puzzle"></a>Towers of Hanoi Puzzle</h3><p>Problem: Find an efficient way to move all of the disks from <strong>one peg to another</strong>, using only <strong>legal moves</strong>.<br>Consider 3 pegs and $n$ disks of different sizes.<br><strong>A legal move</strong> takes a disk from one peg and moves it onto another peg so that it is <strong>not on top of a smaller disk</strong>.</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h4><p>Solution by recursion: very similar to mathematical induction<br>    <strong>Basis step</strong>: If n = 1, moving one disk from one to another is easy.<br>    <strong>Recursive step</strong>: If n &gt; 1, we need 3 steps (e.g., to move n disks from peg 1 to peg 3):<br>        1)n – 1 from 1 to 2<br>        2)largest from 1 to 3<br>        3)n – 1 from 2 to 3</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-25%2002.00.jpeg" alt="图像2024-11-25 02.00" style="zoom:25%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hanoi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123; <span class="comment">//move n disks from peg a to peg c using peg b</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;plate&quot;</span> + n + <span class="string">&quot; from &quot;</span> + a + <span class="string">&quot; to &quot;</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            move(n - <span class="number">1</span>, a, c, b); <span class="comment">//move n-1 disks from a to b using c</span></span><br><span class="line">            System.out.println(<span class="string">&quot;plate&quot;</span> + n + <span class="string">&quot; from &quot;</span> + a + <span class="string">&quot; to &quot;</span> + c); <span class="comment">//move the largest disk from a to c</span></span><br><span class="line">            move(n - <span class="number">1</span>, b, a, c); <span class="comment">//move n-1 disks from b to c using a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Proof-of-correctness-of-solution-by-induction"><a href="#Proof-of-correctness-of-solution-by-induction" class="headerlink" title="Proof of correctness (of solution) by induction:"></a><strong>Proof of correctness (of solution) by induction</strong>:</h4><p>Let $P(n)$ be the predicate that the solution is correct for $n$.<br>Basis step: $P(1)$ is obviously true, i.e., the solution is correct when there is only one disk.<br>Inductive step: From the inductive hypothesis, i.e., $P(k)$ is true for an arbitrary positive integer $k$, we need to show that $P(k + 1)$ is true. That is, if our solution works for $k$ disks, then we can build a correct solution for $k + 1$ disks, which is true by the recursive step:</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-25%2002.10.jpeg" alt="图像2024-11-25 02.10" style="zoom:50%;" /></p><h4 id="Running-Time"><a href="#Running-Time" class="headerlink" title="Running Time"></a><strong>Running Time</strong></h4><p>Let $M(n)$ be the number of disk moves.<br>    <strong>Basic step</strong>: If $n=1$, moving one time only, $M(1)=1$ obviously.<br>    <strong>Recursive step</strong>: If $n&gt;1$, we need three steps, $M(n) = 2M(n-1)+1$ for $n&gt;1$<br>We can guess $M(n)=2^n-1$, proof using <strong>mathematical induction</strong>, thus omitted.</p><h2 id="Recurrence-Relations"><a href="#Recurrence-Relations" class="headerlink" title="Recurrence Relations"></a>Recurrence Relations</h2><p>A recurrence relation or recurrence for a function defined on the set of $integers ≥ b$ tells us how to compute the $nth$ value from some or all of the first $n – 1$ values.<br>To completely specify a function defined by a recurrence, we have to also give the <strong>initial condition(s)</strong> (as known as the <strong>base case(s)</strong>) for the recurrence.<br>Example: running time for Towers of Hanoi</p><script type="math/tex; mode=display">M(n)= \begin{cases} 1& \text{$n=1$}\\ 2M(n-1)+1& \text{$otherwise$} \end{cases}</script><h3 id="Iterating-a-Recurrence"><a href="#Iterating-a-Recurrence" class="headerlink" title="Iterating a Recurrence"></a>Iterating a Recurrence</h3><p>Let $T(n) = rT(n − 1) + a$, where $r$ and $a$ are constants.<br><strong>Find a recurrence relation that expresses</strong><br>    $T(n)$ in terms of $T(n − 2)$<br>    $T(n)$ in terms of $T(n − 3)$<br>    $T(n)$ in terms of $T(n − 4)$<br>    …<br>Can we generalize this to find a <strong>closed-form solution</strong> to $T(n)$?<br>Note that $T(n) = rT(n − 1) + a$ implies that $\forall (n – i) &gt; 0$: $T(n − i) = rT((n − i) − 1)) + a$<br>        $T(n)=rT(n-1)+a=r^2T(n-2)+ra+a=r^3T(n-3)+r^2a+ra+a=…$<br>        Guess: $T(n)=r^nT(0)+a\sum^{n-1}_{i=0}r^i$<br>The technique we used to guess the closed formula of $T(n)$ is called iteration, because we iteratively use the recurrence.<br>The approach we just used is called backward substitution, because we began with $T(n)$ and iterated to express it in terms of falling terms of the sequence until we found it in terms of $T(0)$.</p><h3 id="Closed-Formula-of-Recurrences"><a href="#Closed-Formula-of-Recurrences" class="headerlink" title="Closed Formula of Recurrences"></a>Closed Formula of Recurrences</h3><p>Theorem: If $T(n) = rT(n − 1) + a, T(0) = b$, and $r ≠ 1$, then for all non-negative integers $n$, we have:</p><p>​                                $T(n)=r^nb+a\dfrac{1-r^n}{1-r}$</p><p><strong>Proof by induction</strong>:<br>    <strong>Basis step</strong>: The formula is true for n = 0: $T(0)=r^0b+a\dfrac{1-r^0}{1-r}=b$<br>    <strong>Inductive step</strong>:$T(n) = rT(n-1)+a=r(r^{n-1}b+a\dfrac{1-r^{n-1}}{1-r})=r^nb+\dfrac{ar-ar^n+a+ar}{1-r}=r^nb+a\dfrac{1-r^n}{1-r}$</p><h3 id="First-Order-Linear-Recurrences"><a href="#First-Order-Linear-Recurrences" class="headerlink" title="First Order Linear Recurrences"></a>First Order Linear Recurrences</h3><p>Theorem: For any constants $a$ and $r ≠ 0$, and any function $g$ defined on positive integers, the solution to the recurrence</p><script type="math/tex; mode=display">T(n)= \begin{cases} a& \text{$n=0$}\\ rT(n-1)+g(n)& \text{$n>0$} \end{cases}</script><p>We have $T(n)=r^na+\sum^{n}_{i=1}r^{n-i}g(i)$</p><p>A recurrence relation of the form $T(n) = f(n)T(n − 1) + g(n)$ is called  a first-order linear recurrence.<br>    <strong>First order</strong>: $T(n)$ depends upon going back one step, i.e., $T(n −1)$,<br>                e.g., $T(n) = T(n − 1) + 2T(n − 2)$ is a <strong>second-order</strong> recurrence.<br>    <strong>Linear</strong>: the $T(n − 1)$ only appears to the first power<br>             e.g., $T(n) = (T(n − 1))2 + 3$ is a <strong>non-linear first-order</strong> recurrence.</p><h2 id="Divide-and-Conquer-Recurrences"><a href="#Divide-and-Conquer-Recurrences" class="headerlink" title="Divide-and-Conquer Recurrences"></a>Divide-and-Conquer Recurrences</h2><p><strong>Divide and conquer (D&amp;C)</strong>: recursively breaks down a problem  into two or more sub-problems <strong>of the same or related type</strong>, until  these become simple enough to be solved directly; the solutions  to the sub-problems are then combined to give a solution to the  original problem.</p><p>Divide-and-conquer recurrence relations are usually of the form: <script type="math/tex">T(n)= \begin{cases} \text{something given}& \text{if $n\le n_0$}\\ r\cdot T(\dfrac{n}{m})+g(n)& \text{if $n> n_0$} \end{cases}</script></p><h3 id="Example-Binary-Search"><a href="#Example-Binary-Search" class="headerlink" title="Example: Binary Search"></a>Example: Binary Search</h3><p>Problem: Someone has chosen an integer x between 1 and n. We need to find this secret<br>    We only need to ask two types of questions:<br>        Is x greater than k?<br>        Is x equal to k?<br>Strategy: We first always ask greater than questions, at each step halving our search range, until the range contains only one  number, then we ask a final equal to question.</p><p>D&amp;C: Each guess reduces the size of the problem to only half as  big, then we can (recursively) conquer this smaller problem.<br>When n is a power of 2, the number of comparisons T(n) in a  binary search on {1, 2, …, n} satisfie</p><script type="math/tex; mode=display">T(n)= \begin{cases} 1& \text{$n=1$}\\ T(\dfrac{n}{2})+1& \text{$n\geq2$} \end{cases}</script><p><strong>Proof of correctness</strong> (by strong induction) of the running time:<br>    Basis step ($n = 1$): only one “equal to” comparison is needed<br>    Inductive step ($n ≥ 2$): one “great than” comparison + time to  perform binary search on the remaining $n/2$ term</p><p><strong>Solve by iteration</strong>:<br>$T(n)=T(\dfrac{n}{2})+1=T(\dfrac{n}{2^2})+2=T(\dfrac{n}{2^i})+i$<br>Note that this terminates when $i=log_2n$<br>$T(n)=T(\dfrac{n}{2^{log_2n}})+log_2n=1+log_2n$</p><h3 id="Example-1-T-n-begin-cases-1-text-n-1-2T-dfrac-n-2-n-text-n-geq2-end-cases"><a href="#Example-1-T-n-begin-cases-1-text-n-1-2T-dfrac-n-2-n-text-n-geq2-end-cases" class="headerlink" title="Example 1: T(n)= \begin{cases} 1& \text{$n=1$}\\ 2T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}"></a>Example 1: <script type="math/tex">T(n)= \begin{cases} 1& \text{$n=1$}\\ 2T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 2 subproblems of size $n/2$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n = 1$.<br>    this is exactly how Merge Sort (from an algorithm course) works.</p><p><strong>Solve by iteration</strong>:<br>$T(n)=2T(\dfrac{n}{2})+n=4T(\dfrac{n}{4})+2n=…=2^iT(\dfrac{n}{2^i})+in$<br>Note that this terminates when $i=log_2n$<br>$T(n)=2^{log_2n}T(\dfrac{n}{2^{log_2n}})+n\cdot log_2n=nT(1)+nlog_2n$</p><h3 id="Example-2-T-n-begin-cases-1-text-n-1-T-dfrac-n-2-n-text-n-geq2-end-cases"><a href="#Example-2-T-n-begin-cases-1-text-n-1-T-dfrac-n-2-n-text-n-geq2-end-cases" class="headerlink" title="Example 2: T(n)= \begin{cases} 1& \text{$n=1$}\\ T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}"></a>Example 2: <script type="math/tex">T(n)= \begin{cases} 1& \text{$n=1$}\\ T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 1 subproblem of size $n/2$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n = 1$.</p><p><strong>Solve by iteration</strong>:<br>$T(n)=T(\dfrac{n}{2})+n=T(\dfrac{n}{2^2})+\dfrac{n}{2}+n=T(\dfrac{n}{2^3})+\dfrac{n}{2^2}+\dfrac{n}{2}+n=…=T(\dfrac{n}{2^i})+\dfrac{n}{2^{i-1}}+…+\dfrac{n}{2^2}+\dfrac{n}{2}+n$<br>Note that this teminates when $i=log_2n$<br>$T(n)=T(\dfrac{n}{2^{log_2n}})+\dfrac{n}{2^{log_2n-1}}+…+\dfrac{n}{2^2}+\dfrac{n}{2}+n=1+2+2^2+2^3+…+\dfrac{n}{2^2}+\dfrac{n}{2}+n=2n-1$ <strong>//geometric series’ sum</strong></p><h3 id="Example-3-T-n-begin-cases-1-text-n-1-4T-dfrac-n-2-n-text-n-geq2-end-cases"><a href="#Example-3-T-n-begin-cases-1-text-n-1-4T-dfrac-n-2-n-text-n-geq2-end-cases" class="headerlink" title="Example 3:T(n)= \begin{cases} 1& \text{$n=1$}\\ 4T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}"></a>Example 3:<script type="math/tex">T(n)= \begin{cases} 1& \text{$n=1$}\\ 4T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 4 subproblem of size $n/2$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n = 1$.</p><p><strong>Solve by iteration</strong>:<br>$T(n)= 4T(\dfrac{n}{2})+n=4^2T(\dfrac{n}{2^2})+\dfrac{4}{2}n+n=4^3T(\dfrac{n}{2^3})+\dfrac{4^2}{2^2}n+\dfrac{4}{2}n+n=…=4^iT(\dfrac{n}{2^i})+\dfrac{4^{i-1}}{2^{i-1}}n+…+\dfrac{4}{2}n+n$<br>Note that this teminates when $i=log<em>2n$<br>$T(n)=4^{log_2n}T(\dfrac{n}{2^{log_2n}})+\dfrac{4^{log_2n-1}}{2^{log_2n-1}}n+…+\dfrac{4}{2}n+n=n^2+(\dfrac{n^2/4}{n/2}n)+(\dfrac{n^2/4^2}{n/2^2}n)…+2n+n=n^2+\dfrac{1}{2}n^2+\dfrac{1}{2^2}n^2+…+\dfrac{4}{2}n+n$<br>Part 1 is $4^{log_2n}T(\dfrac{n}{2^{log_2n}})=n^2$<br>Part 2 is $\dfrac{4^{log_2n-1}}{2^{log_2n-1}}n+…+\dfrac{4}{2}n+n$, each item can be written as $2^kn$, which is a geometric series of common ratio 2.<br>Thus, $\sum^{k-1}</em>{i=0}2^i=2^k-1=(n-1)$<br>So, Part 2 = (n-1)n<br>$T(n)= 2n^2-1$</p><h3 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h3><p>Compare the iteration for the following recurrences (T(1) = 1):<br>    $T(n) = T(n / 2) + n$                 $T(n) = 2n – 1 = Θ(n)$<br>    $T(n) = 2T(n / 2) + n$               $T(n) = n + n log_2 n = Θ(n log n)$<br>    $T(n) = 4T(n / 2) + n $               $T(n) = 2n2 – n = Θ(n2)$<br>All three recurrences iterate $log_2n$ times. The size of subproblem in  next iteration is half the size in the preceding iteration level.</p><p><strong>Theorem</strong>: Consider a recurrence relation $T(n) = aT(n / 2) + n$ whenever $n = 2^k$, where $a ≥ 1$ and $T(1) = Θ(1)$.<br>Then we have the  following big Θ bounds on the solution:<br>    If $1 ≤ a &lt; 2$, then $T(n) = Θ(n)$.<br>    If $a = 2$, then $T(n) = Θ(n log n)$.<br>    If $a &gt; 2$, then $T(n) = Θ(n^{log2a}).$ </p><p><strong>Master Theorem</strong>: For a recurrence relation $T(n) = aT(n / b) + cn^d$ whenever $n = b^k$, where $a ≥ 1$, $c &gt; 0$, $d ≥ 0$, integer $b ≥ 2$, and $T(1) = Θ(1)$, we have the following big Θ bounds on the solution:<br>    If $1 ≤ a &lt; b^d$, then $T(n) = Θ(n^d)$.<br>    If $a = b^d$, then $T(n) = Θ(n^d log n)$.<br>    If $a &gt; b^d$, then $T(n) = Θ(n^{log_ba})$.</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="1-Show-that-1-2-···-n-n-n-1-2-for-any-positive-integer-n"><a href="#1-Show-that-1-2-···-n-n-n-1-2-for-any-positive-integer-n" class="headerlink" title="1. Show that $1 + 2 + ··· + n = n(n + 1)/2$ for any positive integer n."></a>1. Show that $1 + 2 + ··· + n = n(n + 1)/2$ for any positive integer n.</h3><p><strong>Proof by mathematical induction:</strong><br>Let P(n) be the predicate that the sum of the first n positive integers is equal to n(n + 1)/2.<br>    <strong>Basis step</strong>: $P(1)$ is true, because $1 = 1(1 + 1)/2$.<br>    <strong>Inductive step</strong>: From the inductive hypothesis, i.e., $P(k)$ is true for an arbitrary positive integer $k$, we need to show that $P(k + 1)$ is true, i.e., $1 + 2 + ··· + k + 1 = (k + 1)((k + 1) + 1)/2$.<br>    $1 + 2 + ··· + k + (k + 1) = k(k + 1)/2 + k + 1 = (k(k + 1) + 2(k + 1))/2 = (k + 1)(k + 2)/2 = (k + 1)((k + 1) + 1)/2$<br>    By mathematical induction, we know that $P(n)$ is true for all positive integers $n$. That is, we have proven that $1 + 2 + ··· + n = n(n + 1)/2$ <strong>holds</strong> for <strong>all</strong> positive integers $n$.</p><h3 id="2-Prove-that-for-any-integer-n-≥-2-2-n-1-≥-n-2-3"><a href="#2-Prove-that-for-any-integer-n-≥-2-2-n-1-≥-n-2-3" class="headerlink" title="2. Prove that for any integer $n ≥ 2, 2^{n+1} ≥ n^2 + 3$ ."></a>2. Prove that for any integer $n ≥ 2, 2^{n+1} ≥ n^2 + 3$ .</h3><p><strong>Proof by mathematical induction:</strong><br>Let $P(n)$ be the predicate that $\forall n ≥ 2, 2^{n+1} ≥ n^2 + 3$<br>    <strong>Basic step</strong>: $P(1)$ is true, because $2^{1+1}=4 \geq 1^2+3=4$<br>    <strong>Inductive step</strong>: From the inductive hypothesis, i.e., $P(k)$ is true for an arbitrary positive integer $k$, we need to show that $P(k + 1)$ is true, i.e., $2^{(k+1)+1} \geq (k+1)^2+3$<br>    $2^{(k+1)+1} \geq 2 \cdot2^{(k+1)} \geq 2(k^2+3) = 2k^2+6=(k+1)^2+(k-1)^2+4\geq (k+1)^2+3$<br>By mathematical induction, $P(n)$ is true for <strong>all</strong> integers $n ≥ 2$.</p><h3 id="3-Prove-Every-positive-integer-is-a-power-of-a-prime-or-the-product-of-powers-of-primes"><a href="#3-Prove-Every-positive-integer-is-a-power-of-a-prime-or-the-product-of-powers-of-primes" class="headerlink" title="3. Prove: Every positive integer is a power of a prime or the product of powers of primes."></a>3. Prove: Every positive integer is a power of a prime or the product of powers of primes.</h3><p>Proof by strong induction: $P(n)$: “$n$ is a power of a prime or the product of powers of primes”<br>    <strong>Basis step</strong>: $P(1)$ is true, as 1 is a power of a prime number, $1 = 2^0$<br>    <strong>Inductive step</strong>: Inductive hypothesis: $P(m)$ is true for every $m$ that $1 ≤ m ≤ k$, i.e., $m$ is a power of a prime or a product of powers of primes.<br>    If $k + 1$ is a prime power, $P(k + 1)$ is true.<br>    Otherwise, $k + 1$ must be a composite, i.e., a product of two smaller positive integers, each of which is, by the inductive hypothesis, a power of a prime or the product of powers of primes. Therefore, $P(k + 1)$ is true.<br>    Finally, by strong induction, $P(n)$ is true for all positive integers.</p><h3 id="4-Solve-T-n-rT-n-−-1-g-n-with-T-0-a-and-constant-r-≠-0"><a href="#4-Solve-T-n-rT-n-−-1-g-n-with-T-0-a-and-constant-r-≠-0" class="headerlink" title="4. Solve $T(n) = rT(n − 1) + g(n)$ with $T(0) = a$ and constant $r ≠ 0$."></a>4. Solve $T(n) = rT(n − 1) + g(n)$ with $T(0) = a$ and constant $r ≠ 0$.</h3><p>Hint: write $T(n)$ in terms of $r, n$, $T(0)$ and $g(i)$</p><p>$T(n) = rT(n − 1) + g(n)=r(rT(n − 2) + g(n-1))+g(n)=r^2T(n-2)+rg(n-1)+g(n)=…$</p><p>We have $T(n)=r^nT(0)+\sum^{n-1}_{i=0}r^{i}g(n-i)$</p><h3 id="5-Solve-T-n-4T-n-−-1-2-n-n-gt-0-with-T-0-6"><a href="#5-Solve-T-n-4T-n-−-1-2-n-n-gt-0-with-T-0-6" class="headerlink" title="5. Solve $T(n) = 4T(n − 1) + 2^n (n &gt; 0)$ with $T(0) = 6$"></a>5. Solve $T(n) = 4T(n − 1) + 2^n (n &gt; 0)$ with $T(0) = 6$</h3><p>Hint: write $T(n)$ in terms of $4^n$ and $2^n$</p><p>$T(n)=4^n\cdot6+\sum^{n}<em>{i=1}4^{n-i}2^i=4^n\cdot6+4^n\sum^n</em>{i=1}4^{-i}\cdot2^i=4^n\cdot6+4^n\sum^n_{i=1}(\frac{1}{2})^i=4^n\cdot6+4^n\cdot(1-\dfrac{1}{2^n})=7\cdot4^n-2^n$</p><h3 id="6-Solve-this-recurrence-by-iteration-T-n-begin-cases-1-text-n"><a href="#6-Solve-this-recurrence-by-iteration-T-n-begin-cases-1-text-n" class="headerlink" title="6.Solve this recurrence by iteration T(n)= \begin{cases} 1& \text{$n"></a>6.Solve this recurrence by iteration <script type="math/tex">T(n)= \begin{cases} 1& \text{$n<3$}\\ 3T(\dfrac{n}{3})+n& \text{$n\geq3$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 3 subproblem of size $n/3$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n &lt;3$.</p><p>$T(n)=3T(\dfrac{n}{3})+n=3^2T(\dfrac{n}{3^2})+2n=…=3^iT(\dfrac{n}{3^i})+in$<br>Note that this teminates when $i=log_3n$<br>$T(n)=3^{log_3n}T(\dfrac{n}{3^{log_3n}})+nlog_3n=nT(1)+nlog_3n=n+nlog_3n$</p>]]></content>
      
      
      <categories>
          
          <category> Discrete Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discrete Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic</title>
      <link href="/2024/11/23/Digital%20Logic%20Chapter%205%20part%202:Synchronous%20Sequential%20Logic/"/>
      <url>/2024/11/23/Digital%20Logic%20Chapter%205%20part%202:Synchronous%20Sequential%20Logic/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-2-Synchronous-Sequential-Logic"><a href="#Digital-Logic-Chapter-5-part-2-Synchronous-Sequential-Logic" class="headerlink" title="Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic"></a>Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic</h1><h2 id="Analysis-of-Sequential-Circuits"><a href="#Analysis-of-Sequential-Circuits" class="headerlink" title="Analysis of Sequential Circuits"></a>Analysis of Sequential Circuits</h2><h3 id="Ways-to-describe-a-digital-circuit"><a href="#Ways-to-describe-a-digital-circuit" class="headerlink" title="Ways to describe a digital circuit"></a>Ways to describe a digital circuit</h3><p>logic diagram (逻辑电路图): graphical representation of a digital circuit that uses standard symbols</p><p>K-map (卡诺图): graphical representation of a logic function used to simplify Boolean expressions</p><p>function table (功能表)(truth table): list of all possible input combinations and the corresponding output values for a given logic function</p><p>characteristic equations (特征方程): Describe the behavior of a sequential logic circuit, the next state is defined as a function of the inputs and the present state</p><p>excitation/input equation (激励方程): Defines the part of the circuit that generates the inputs to sequential logic circuit</p><p>state table (状态表): tabular representation of a sequential logic circuit that shows the current state, input, next state, and output for all possible input combinations</p><p>state equation (次态方程): defines the next state of a sequential logic circuit based on the current state and input values</p><p>state diagram (状态图): graphical representation of a sequential logic circuit that shows the states, transitions, and input-output relationships</p><h3 id="Analysis-Procedure-of-Clocked-Sequential-Circuits"><a href="#Analysis-Procedure-of-Clocked-Sequential-Circuits" class="headerlink" title="Analysis Procedure of Clocked Sequential Circuits"></a>Analysis Procedure of Clocked Sequential Circuits</h3><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h4><ol><li>Derive excitation/input equations for FF inputs</li><li>Derive state and output equations<br> Substitute the excitation equations into the flip-flop characteristic equations to obtain next state equations.<br> Determine the output equations according current state and input </li><li>Generate state and output tables</li><li>Generate state diagram</li></ol><p>Important: FF’s Characteristic equation:<br>DFF   $Q(t+1) = D(t)$<br>JKFF $Q(t+1) = J(t)Q(t)’ + K(t)’Q(t)$<br>TFF   $Q(t+1) = T(t)’Q(t) + T(t)Q(t)’$</p><h4 id="Example-1-using-DFF-Q-t-1-D-t"><a href="#Example-1-using-DFF-Q-t-1-D-t" class="headerlink" title="Example 1 using DFF $Q(t+1) = D(t)$:"></a>Example 1 using DFF $Q(t+1) = D(t)$:</h4><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2021.56.jpeg" alt="图像2024-11-23 21.56" style="zoom:33%;" /></p><ol><li>Derive excitation/input equations for FF inputs<br> $D_A = Q_Ax + Q_Bx$<br> $D_B = Q_A’x$</li><li>State equation<br> $Q_A(t+1) = D_A(t)=Q_Ax + Q_Bx$<br> $Q_B(t+1) = D_B(t) = Q_A’(t)x(t)$</li><li>Output equation<br> $y(t) = (Q_A(t) + Q_B(t))x’(t)$<br> All signals are labeled by t, thus $y = (Q_A + Q_B)x’$</li><li>Generate state and output tables</li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>Output</th></tr></thead><tbody><tr><td>$Q_A$</td><td>$Q_B$</td><td>$x$</td><td>$Q_{Anext}$</td><td>$Q_{Bnext}$</td><td>$y$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><ol><li><p>Generate state diagram</p><p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2022.45.jpeg" alt="图像2024-11-23 22.45" style="zoom:33%;" /></p></li></ol><h4 id="Example-2-using-JKFF-Q-t-1-J-t-Q-t-’-K-t-’Q-t"><a href="#Example-2-using-JKFF-Q-t-1-J-t-Q-t-’-K-t-’Q-t" class="headerlink" title="Example 2 using JKFF $Q(t+1) = J(t)Q(t)’ + K(t)’Q(t)$:"></a>Example 2 using JKFF $Q(t+1) = J(t)Q(t)’ + K(t)’Q(t)$:</h4><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2022.48.jpeg" alt="图像2024-11-23 22.48" style="zoom:33%;" /></p><ol><li><p>Derive excitation/input equations for FF inputs<br>$J_A = B$<br>$K_A= Bx’$<br>$J_B=x’$<br>$K_B=A \oplus x$</p></li><li><p>State equation<br>$A(t+1) = J_AA’ + K_A’A= BA’ + (Bx’)’A$<br>$B(t+1) = J_BB’ + K’_BB=B’x’ +(A \oplus x)’B $</p></li><li><p>No extra output equations</p></li><li><p>Generate state and output tables</p></li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>FF inputs</th><th>FF inputs</th><th>FF inputs</th><th>FF inputs</th></tr></thead><tbody><tr><td>$A$</td><td>$B$</td><td>$x$</td><td>$A_{next}$</td><td>$B_{next}$</td><td>$J_A$</td><td>$K_A$</td><td>$J_B$</td><td>$K_B$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><ol><li>Generate state diagram<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.10.jpeg" alt="图像2024-11-23 23.10" style="zoom:33%;" /></li></ol><h4 id="Example-3-using-TFF-Q-t-1-T-t-’Q-t-T-t-Q-t-’"><a href="#Example-3-using-TFF-Q-t-1-T-t-’Q-t-T-t-Q-t-’" class="headerlink" title="Example 3 using TFF $Q(t+1) = T(t)’Q(t) + T(t)Q(t)’$:"></a>Example 3 using TFF $Q(t+1) = T(t)’Q(t) + T(t)Q(t)’$:</h4><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.16.jpeg" alt="图像2024-11-23 23.16" style="zoom:40%;" /></p><ol><li><p>Derive excitation/input equations for FF inputs<br>$T_A = Bx$<br>$T_B = x$</p></li><li><p>State equation<br>$A(t+1) = T_A \oplus Q_A = (Bx) \oplus A$<br>$B(t+1)=T_B \oplus Q_B = x \oplus B$</p></li><li><p>Output equation<br>$y = AB$</p></li><li><p>Generate state and output tables</p></li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>Output</th></tr></thead><tbody><tr><td>$A$</td><td>$B$</td><td>$x$</td><td>$A_{next}$</td><td>$B_{next}$</td><td>$y$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><ol><li>Generate state diagram<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.29.jpeg" alt="图像2024-11-23 23.29" style="zoom:33%;" /></li></ol><h2 id="Finite-State-Machine"><a href="#Finite-State-Machine" class="headerlink" title="Finite State Machine"></a>Finite State Machine</h2><p>A synchronous sequential circuit can be modeled by FSM.</p><p>State register $𝑞(t+1) = 𝑞_{next}(t)$<br>    Stores current state<br>    Loads next state at clock edge</p><p>Combinational logic<br>    Computes next state (next state logic $h: x × 𝑞 → 𝑞_{𝑛𝑒𝑥𝑡}$ )<br>    Computes outputs<br>        output logic $f: x × 𝑞 → 𝑦$ (Mealy machine, with blue line)<br>                or $f: 𝑞 → 𝑦$ (Moore machine, without blue line)</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.47.jpeg" alt="图像2024-11-23 23.47" style="zoom:33%;" /></p><p>Two types of finite state machines differ in output logic:<br>    Moore FSM: outputs depend only on current state<br>    Mealy FSM: outputs depend on current state and inputs, to synchronize a Mealy circuit, the inputs must be synchronized with the clock and the outputs must be sampled immediately before the clock edge</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.56.jpeg" alt="图像2024-11-23 23.56" style="zoom:33%;" /></p><h2 id="State-Minimization-amp-Encoding"><a href="#State-Minimization-amp-Encoding" class="headerlink" title="State Minimization &amp; Encoding"></a>State Minimization &amp; Encoding</h2><h3 id="State-minimization"><a href="#State-minimization" class="headerlink" title="State minimization"></a>State minimization</h3><p>Reductions on the number of flip-flops (states) and the number of gates.<br>For an FSM with m states, we need $log_2m$ FFs.</p><p>Reduction steps</p><ol><li>Find rows in the state table that have identical next state and output entries. They correspond to equivalent states. If there are no equivalent states, stop.</li><li>When 2 states are equivalent, one of them can be removed. Update the entries of the remaining table to cancel the removed state. Go to 1.</li></ol><p>Example:<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2000.27.jpeg" alt="图像2024-11-24 00.27" style="zoom:50%;" /> $\longrightarrow$<img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2000.29.jpeg" alt="图像2024-11-24 00.29" style="zoom:50%;" /></p><p><strong>Start table:</strong></p><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td>d</td><td>e</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>e</u></td><td><u>a</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr><tr><td>f</td><td>g</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>g</u></td><td><u>a</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr></tbody></table></div><p><strong>1st turn:</strong> $e \equiv g$</p><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td><u>d</u></td><td><u>e</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr><tr><td>e</td><td>a</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>f</u></td><td><del>g</del>   <u>e</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr></tbody></table></div><p><strong>2nd turn:</strong> $d \equiv f$</p><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td>d</td><td>e</td><td><del>f</del>   d</td><td>0</td><td>1</td></tr><tr><td>e</td><td>a</td><td><del>f</del>   d</td><td>0</td><td>1</td></tr></tbody></table></div><h3 id="Encoding-assign-binary-state-to-the-states"><a href="#Encoding-assign-binary-state-to-the-states" class="headerlink" title="Encoding(assign binary state to the states)"></a>Encoding(assign binary state to the states)</h3><p>Different state encodings (assignments) result in different circuits for the intended FSM.<br>There is no easy state-encoding procedure that guarantees a minimal-cost or minimum-delay combinational circuits<br>    Exploration of all possibilities are impossible.<br>    Heuristic are often used.<br>        Binary counting<br>        Minimum-bit change<br>        One-hot encoding</p><h2 id="Design-of-Sequential-Circuits"><a href="#Design-of-Sequential-Circuits" class="headerlink" title="Design of Sequential Circuits"></a>Design of Sequential Circuits</h2><h3 id="Design-Procedure-of-Sequential-Circuits"><a href="#Design-Procedure-of-Sequential-Circuits" class="headerlink" title="Design Procedure of Sequential Circuits"></a>Design Procedure of Sequential Circuits</h3><ol><li>Specification: design description or timing diagram</li><li>Formulation: develop state diagram</li><li>Generate state and output tables</li><li>Minimize States if necessary</li><li>Assign binary values to the state (encoding)</li><li>Derive state and output equations</li><li><strong>Choose memory elements (DFFs, JKFFs, TFFs)</strong></li><li>Derive simplified excitation/input equations and output equations</li><li>Draw logic schematic</li></ol><h3 id="Choice-of-Memory-Elements"><a href="#Choice-of-Memory-Elements" class="headerlink" title="Choice of Memory Elements"></a>Choice of Memory Elements</h3><p>Given the state transition table, we wish to find the FF input conditions that will cause the required transition.<br>    A tool for such a purpose is the excitation table, which can be derived from the characteristic table/equation.<br>    D FFs are good for applications requiring data transfer (shift registers).<br>    T FFs are good for those involving complementation (binary counters).<br>    Many digital systems are constructed entirely with JK FFs because they are the most versatile available.</p><h3 id="FF’s-Excitation-Table"><a href="#FF’s-Excitation-Table" class="headerlink" title="FF’s Excitation Table"></a>FF’s Excitation Table</h3><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.51.jpeg" alt="图像2024-11-24 01.51" style="zoom:33%;" /></p><h3 id="Design-Example-Design-with-DFF-A-Sequence-Detector"><a href="#Design-Example-Design-with-DFF-A-Sequence-Detector" class="headerlink" title="Design Example: Design with DFF: A Sequence Detector"></a>Design Example: Design with DFF: A Sequence Detector</h3><ol><li><p>Detect three consecutive 1’s in a string of bits (using Moore machine, overlapping)<br>If detected, output=1; otherwise output=0</p></li><li><p>State diagram<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.15.jpeg" alt="图像2024-11-24 01.15" style="zoom:33%;" /></p></li><li><p>State and output table</p></li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td>$S(AB)$</td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>$S_0 (00)$</td><td>$S_0$</td><td>$S_1$</td><td>0</td><td>0</td></tr><tr><td>$S_1(01)$</td><td>$S_0$</td><td>$S_2$</td><td>0</td><td>0</td></tr><tr><td>$S_2(10)$</td><td>$S_0$</td><td>$S_3$</td><td>0</td><td>0</td></tr><tr><td>$S_3(11)$</td><td>$S_0$</td><td>$S_3$</td><td>1</td><td>1</td></tr></tbody></table></div><ol><li><p>No need for simplification</p></li><li><p>State assignment in 3</p></li><li><p>Derive state and output equations</p></li></ol><div class="table-container"><table><thead><tr><th>$A(t)$</th><th>$B(t)$</th><th>$x$</th><th>$A(t+1)$</th><th>$B(t+1)$</th><th>$y$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>  $A(t+1)=D_A(A(t),B(t),x)=\Sigma(3,5,7)$<br>  $B(t+1)=D_B(A(t),B(t),x)=\Sigma(1,5,7)$<br>  $y(A,B,x)=\Sigma(6,7)$</p><ol><li><p>Choose DFFs<br>2 bits encoding leads to 2 DFFs.<br>$A(t+1) =D_A(t)$<br>$B(t+1)=D_B(t)$</p></li><li><p>Derive simplified excitation/input equations and output equations<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.47.jpeg" alt="图像2024-11-24 01.47" style="zoom:40%;" /><br>$D_A=Ax+Bx$<br>$D_B=Ax+B’x$<br>$y=AB$</p></li><li><p>Logic schematic(Omitted)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital Logic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</title>
      <link href="/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/"/>
      <url>/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops"><a href="#Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops" class="headerlink" title="Digital Logic Chapter 5 part 1 - Latches and Flip-flops"></a>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</h1><h2 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h2><p>A sequential circuit consists of a combinational circuit to which storage elements are connected to form a feedback path.<br>The binary information stored in the memory elements at any given time defines the state of the sequential circuits.<br>$(inputs, current State)$ $\Longrightarrow$ $(outputs, next State)$, the behavior is specified by a time sequence of inputs and internal states.</p><h3 id="Synchronous-Sequential-Circuits"><a href="#Synchronous-Sequential-Circuits" class="headerlink" title="Synchronous Sequential Circuits"></a>Synchronous Sequential Circuits</h3><p>A system whose behavior can be defined from the knowledge of its signals at <strong>discrete</strong> instants of time.<br>Usually achieved by a timing device: clock generator, which means the outputs are affected only with the application of a clock pulse.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.04.jpeg" alt=""></p><h3 id="Asynchronous-Sequential-Circuits"><a href="#Asynchronous-Sequential-Circuits" class="headerlink" title="Asynchronous Sequential Circuits"></a>Asynchronous Sequential Circuits</h3><p>A system whose behavior depends upon input signals at <strong>any</strong> instant of time and the order in which the inputs change.<br>Commonly used storage devices are time-delay devices, and the propagation delay of the logic gates (time-delay devices) provides the required storage.<br>Can be viewed as combinational circuit with feedback, and can be unstable at times</p><h2 id="Storage-Elements"><a href="#Storage-Elements" class="headerlink" title="Storage Elements"></a>Storage Elements</h2><p>State: all the information about a circuit necessary to explain its future behavior </p><h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><h4 id="SR-Latch"><a href="#SR-Latch" class="headerlink" title="SR Latch"></a>SR Latch</h4><h5 id="SR-Latch-1"><a href="#SR-Latch-1" class="headerlink" title="SR Latch"></a>SR Latch</h5><p>It stores 1 bit of infomation, consists of two cross-coupled NOR gates or NAND gates.<br>Two input signals: $set(S)/Reset(R)$<br>Two output signals: $Q/Q’$<br>Two useful states: $setState(Q=1,Q’=0)/resetState(Q=0,Q’=1)$<br>Note: $Q$ and $Q’$ should always be different. And $(S,R)$ should go back to $(0,0)$ before any other changes to avoid the occurrence of the undefined state.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.23.jpeg" style="zoom:28%;" /></p><p>Consider 4 possible cases:<br>1.$S=1,R=0$ $\Longrightarrow$ $Q=1,Q’=0$ <strong>Set the output</strong>.<br>2.$S=0,R=1$ $\Longrightarrow$ $Q=0,Q’=1$ <strong>Reset the output</strong>.<br>3.$S=0,R=0$ $\Longrightarrow$ $Q=Q<em>{prev},Q’=Q’</em>{prev}$ <strong>Memory function</strong>.<br>4.$S=1,R=1$ $\Longrightarrow$ $Q=0,Q’=0$ <strong>Forbidden invalid state</strong>.</p><div class="table-container"><table><thead><tr><th style="text-align:left">$S$</th><th style="text-align:left">$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table></div><h5 id="S’R’-Latch-with-NAND-gates"><a href="#S’R’-Latch-with-NAND-gates" class="headerlink" title="S’R’ Latch with NAND gates"></a>S’R’ Latch with NAND gates</h5><p><strong>Low active</strong> Set/Reset inputs<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.36.jpeg" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>Forbidden</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr></tbody></table></div><h5 id="Clocked-SR-Latch"><a href="#Clocked-SR-Latch" class="headerlink" title="Clocked SR Latch"></a>Clocked SR Latch</h5><p>Use Clock (or En) to enable/disable the SR latch<br>$C=0$, no change(disabled)<br>$C=1$, operates as normal SR latch (enabled)<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.42.jpeg" style="zoom:30%;" /></p><div class="table-container"><table><thead><tr><th>$C$</th><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>0</td><td>0</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table></div><h4 id="D-Latch"><a href="#D-Latch" class="headerlink" title="D Latch"></a>D Latch</h4><p>It stores 1 bit of infomation, constructed from a gated SR latch by connecting the D input to S input and D’ to R, which makes sure S and R are different in the SR Latch.<br>Two input signals: $Clock(clk/En)/Data(D)$<br>Two output signals: $Q/Q’$<br>Note: avoid invalid cases in SR Latches.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48.jpeg" alt="图像2024-11-22 10.48" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48%20(1).jpeg" alt="图像2024-11-22 10.48 (1)" style="zoom:38%;" /></p><div class="table-container"><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change(Memory)</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table></div><h3 id="Flip-flop"><a href="#Flip-flop" class="headerlink" title="Flip-flop"></a>Flip-flop</h3><h4 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h4><h5 id="Level-sensitive"><a href="#Level-sensitive" class="headerlink" title="Level sensitive"></a>Level sensitive</h5><p>The state transition starts as soon as the clock is during logic 1 (positive level-sensitive) or logic 0 (negative level-sensitive) level.</p><h5 id="Edge-triggered"><a href="#Edge-triggered" class="headerlink" title="Edge triggered"></a>Edge triggered</h5><p>The state transition starts only at positive (positive edge-triggered) or negative edge (negative edge-triggered) of the clock signal.</p><h4 id="D-Flip-flop"><a href="#D-Flip-flop" class="headerlink" title="D Flip-flop"></a>D Flip-flop</h4><h5 id="Standard-DFF-Properties"><a href="#Standard-DFF-Properties" class="headerlink" title="Standard DFF Properties"></a>Standard DFF Properties</h5><p>Inputs: $Clk$,$D$<br>A D flip-flop is formed by two separate latches:<br>A master D latch (negative level sensitive)<br>A slave D latch (positive level sensitive)<br>Positive-edge-triggered D flip-flop:<br>When $CLK = 0$:<br>    master is transparent<br>    slave is opaque<br>    D passes through to P<br>When $CLK = 1$<br>    master is opaque<br>    slave is transparent<br>    P passes through to Q<br>Thus, on the rising edge of the clock ($CLK$ rises from 0$\rightarrow$1)<br>    D passes through to Q<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2013.27.jpeg" alt="图像2024-11-22 13.27" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>↑</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table></div><h5 id="Setup-time-and-hold-time"><a href="#Setup-time-and-hold-time" class="headerlink" title="Setup time and hold time"></a>Setup time and hold time</h5><p><strong>Setup time</strong><br>    D input must be maintained at a constant value prior to the application of the positive Clk pulse<br><strong>Hold time</strong><br>    Data input must not change after the application of the positive Clk pulse</p><h5 id="DFF-with-Reset"><a href="#DFF-with-Reset" class="headerlink" title="DFF with Reset"></a>DFF with Reset</h5><p>Active low reset<br>$Reset = 0$: Q is forced to 0<br>$Reset = 1$: flip-flop behaves as ordinary D flip-flop</p><div class="table-container"><table><thead><tr><th>$R$</th><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>0</td><td>1</td><td>Reset on power, forced $Q = 0$</td></tr><tr><td>1</td><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>$\uparrow$</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2014.06.jpeg" alt="图像2024-11-22 14.06" style="zoom:40%;" /></p><p>The state of FFs are unknown when power is on. A direct input can force the FFs to a known state before the system starts.<br>    E.g. when $Reset = 1$, FF’s output is forced to 0<br>Synchronous vs. asynchronous resettable Flip Flop<br>    Asynchronous: resets immediately when $Reset = 1$<br>    Synchronous: resets at the clock edge only</p><h4 id="J-K-Flip-flop"><a href="#J-K-Flip-flop" class="headerlink" title="J-K Flip-flop"></a>J-K Flip-flop</h4><p>e.g. <strong>Positive edge-triggered JKFF</strong></p><p>At rising edge of clock<br>$J = K = 0$, Q is unchanged<br>$J = K = 1$, Q toggles<br>$J = 1, K = 0$, Q is set to 1<br>$J = 0, K = 1$, Q is reset to 0<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="图像2024-11-22 16.01" style="zoom:33%;" /></p><p><strong>Characteristic equation:</strong></p><script type="math/tex; mode=display">Q(t+1)= J’K’Q(t) + J’K•0 + JK’•1 + JKQ(t)’= J’K’Q(t) + JK’ + JKQ(t)’= J’K’Q(t) + JK’Q(t) + JK’Q(t)’ + JKQ(t)’= JQ(t)’ + K’Q(t)</script><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.21.jpeg" alt="图像2024-11-22 16.21" style="zoom:33%;" /></p><h4 id="T-Flip-flop"><a href="#T-Flip-flop" class="headerlink" title="T Flip-flop"></a>T Flip-flop</h4><p>T: Toggle<br>$T = 0$, a clock edge does not change the output.<br>$T = 1$, a clock edge complements the output.<br>Useful for designing binary counters.</p><div class="table-container"><table><thead><tr><th>$T$</th><th>$Q_{next}$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>$Q$</td><td>no change</td></tr><tr><td>1</td><td>$Q’$</td><td>take $Q$’s complement</td></tr></tbody></table></div><p><strong>Characteristic equation:</strong></p><script type="math/tex; mode=display">Q(t+1) = T’Q(t) + TQ(t)’= T⊕Q(t)</script><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2021.03.jpeg" alt="图像2024-11-22 21.03" style="zoom:33%;" /></p><h3 id="Characteristic-Table"><a href="#Characteristic-Table" class="headerlink" title="Characteristic Table"></a>Characteristic Table</h3><p><strong>Characteristic table</strong>: describe the behavior of a flip-flop based on its input and current state Q(t) just before the rising edge of the clock, and the resulting next state Q(t+1) after the clock transition.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="图像2024-11-22 16.01" style="zoom:40%;" /></p><p><strong>Characteristic equation</strong>: derived from the Characteristic table, e.g. $Q_{t+1} = D$</p><ol><li>From characteristic table to truth table</li><li>Algebrically or using K-map to get characteristic equation</li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital Logic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FirstPost</title>
      <link href="/2024/11/21/FirstPost/"/>
      <url>/2024/11/21/FirstPost/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
