<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic</title>
      <link href="/2024/11/23/Digital%20Logic%20Chapter%205%20part%202:Synchronous%20Sequential%20Logic/"/>
      <url>/2024/11/23/Digital%20Logic%20Chapter%205%20part%202:Synchronous%20Sequential%20Logic/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-2-Synchronous-Sequential-Logic"><a href="#Digital-Logic-Chapter-5-part-2-Synchronous-Sequential-Logic" class="headerlink" title="Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic"></a>Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic</h1><h2 id="Analysis-of-Sequential-Circuits"><a href="#Analysis-of-Sequential-Circuits" class="headerlink" title="Analysis of Sequential Circuits"></a>Analysis of Sequential Circuits</h2><h3 id="Ways-to-describe-a-digital-circuit"><a href="#Ways-to-describe-a-digital-circuit" class="headerlink" title="Ways to describe a digital circuit"></a>Ways to describe a digital circuit</h3><p>logic diagram (é€»è¾‘ç”µè·¯å›¾): graphical representation of a digital circuit that uses standard symbols</p><p>K-map (å¡è¯ºå›¾): graphical representation of a logic function used to simplify Boolean expressions</p><p>function table (åŠŸèƒ½è¡¨)(truth table): list of all possible input combinations and the corresponding output values for a given logic function</p><p>characteristic equations (ç‰¹å¾æ–¹ç¨‹): Describe the behavior of a sequential logic circuit, the next state is defined as a function of the inputs and the present state</p><p>excitation&#x2F;input equation (æ¿€åŠ±æ–¹ç¨‹): Defines the part of the circuit that generates the inputs to sequential logic circuit</p><p>state table (çŠ¶æ€è¡¨): tabular representation of a sequential logic circuit that shows the current state, input, next state, and output for all possible input combinations</p><p>state equation (æ¬¡æ€æ–¹ç¨‹): defines the next state of a sequential logic circuit based on the current state and input values</p><p>state diagram (çŠ¶æ€å›¾): graphical representation of a sequential logic circuit that shows the states, transitions, and input-output relationships</p><h3 id="Analysis-Procedure-of-Clocked-Sequential-Circuits"><a href="#Analysis-Procedure-of-Clocked-Sequential-Circuits" class="headerlink" title="Analysis Procedure of Clocked Sequential Circuits"></a>Analysis Procedure of Clocked Sequential Circuits</h3><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h4><ol><li>Derive excitation&#x2F;input equations for FF inputs</li><li>Derive state and output equations<br> Substitute the excitation equations into the flip-flop characteristic equations to obtain next state equations.<br> Determine the output equations according current state and input </li><li>Generate state and output tables</li><li>Generate state diagram</li></ol><p>Important: FFâ€™s Characteristic equation:<br>DFF   $Q(t+1) &#x3D; D(t)$<br>JKFF $Q(t+1) &#x3D; J(t)Q(t)â€™ + K(t)â€™Q(t)$<br>TFF   $Q(t+1) &#x3D; T(t)â€™Q(t) + T(t)Q(t)â€™$</p><h4 id="Example-1-using-DFF-Q-t-1-D-t"><a href="#Example-1-using-DFF-Q-t-1-D-t" class="headerlink" title="Example 1 using DFF $Q(t+1) &#x3D; D(t)$:"></a>Example 1 using DFF $Q(t+1) &#x3D; D(t)$:</h4><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2021.56.jpeg" alt="å›¾åƒ2024-11-23 21.56" style="zoom:33%;" /><ol><li><p>Derive excitation&#x2F;input equations for FF inputs<br> $D_A &#x3D; Q_Ax + Q_Bx$<br> $D_B &#x3D; Q_Aâ€™x$</p></li><li><p>State equation<br> $Q_A(t+1) &#x3D; D_A(t)&#x3D;Q_Ax + Q_Bx$<br> $Q_B(t+1) &#x3D; D_B(t) &#x3D; Q_Aâ€™(t)x(t)$</p></li><li><p>Output equation<br> $y(t) &#x3D; (Q_A(t) + Q_B(t))xâ€™(t)$<br> All signals are labeled by t, thus $y &#x3D; (Q_A + Q_B)xâ€™$</p></li><li><p>Generate state and output tables</p><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>Output</th></tr></thead><tbody><tr><td>$Q_A$</td><td>$Q_B$</td><td>$x$</td><td>$Q_{Anext}$</td><td>$Q_{Bnext}$</td><td>$y$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></li><li><p>Generate state diagram</p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2022.45.jpeg" alt="å›¾åƒ2024-11-23 22.45" style="zoom:33%;" /></li></ol><h4 id="Example-2-using-JKFF-Q-t-1-J-t-Q-t-â€™-K-t-â€™Q-t"><a href="#Example-2-using-JKFF-Q-t-1-J-t-Q-t-â€™-K-t-â€™Q-t" class="headerlink" title="Example 2 using JKFF $Q(t+1) &#x3D; J(t)Q(t)â€™ + K(t)â€™Q(t)$:"></a>Example 2 using JKFF $Q(t+1) &#x3D; J(t)Q(t)â€™ + K(t)â€™Q(t)$:</h4><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2022.48.jpeg" alt="å›¾åƒ2024-11-23 22.48" style="zoom:33%;" /><ol><li><p>Derive excitation&#x2F;input equations for FF inputs<br> $J_A &#x3D; B$<br> $K_A&#x3D; Bxâ€™$<br> $J_B&#x3D;xâ€™$<br> $K_B&#x3D;A \oplus x$</p></li><li><p>State equation<br> $A(t+1) &#x3D; J_AAâ€™ + K_Aâ€™A&#x3D; BAâ€™ + (Bxâ€™)â€™A$<br> $B(t+1) &#x3D; J_BBâ€™ + Kâ€™_BB&#x3D;Bâ€™xâ€™ +(A \oplus x)â€™B $</p></li><li><p>No extra output equations</p></li><li><p>Generate state and output tables</p><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>FF inputs</th><th>FF inputs</th><th>FF inputs</th><th>FF inputs</th></tr></thead><tbody><tr><td>$A$</td><td>$B$</td><td>$x$</td><td>$A_{next}$</td><td>$B_{next}$</td><td>$J_A$</td><td>$K_A$</td><td>$J_B$</td><td>$K_B$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></li><li><p>Generate state diagram</p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.10.jpeg" alt="å›¾åƒ2024-11-23 23.10" style="zoom:33%;" /></li></ol><h4 id="Example-3-using-TFF-Q-t-1-T-t-â€™Q-t-T-t-Q-t-â€™"><a href="#Example-3-using-TFF-Q-t-1-T-t-â€™Q-t-T-t-Q-t-â€™" class="headerlink" title="Example 3 using TFF $Q(t+1) &#x3D; T(t)â€™Q(t) + T(t)Q(t)â€™$:"></a>Example 3 using TFF $Q(t+1) &#x3D; T(t)â€™Q(t) + T(t)Q(t)â€™$:</h4><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.16.jpeg" alt="å›¾åƒ2024-11-23 23.16" style="zoom:40%;" /><ol><li><p>Derive excitation&#x2F;input equations for FF inputs<br> $T_A &#x3D; Bx$<br> $T_B &#x3D; x$</p></li><li><p>State equation<br> $A(t+1) &#x3D; T_A \oplus Q_A &#x3D; (Bx) \oplus A$<br> $B(t+1)&#x3D;T_B \oplus Q_B &#x3D; x \oplus B$</p></li><li><p>Output equation<br> $y &#x3D; AB$</p></li><li><p>Generate state and output tables</p><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>Output</th></tr></thead><tbody><tr><td>$A$</td><td>$B$</td><td>$x$</td><td>$A_{next}$</td><td>$B_{next}$</td><td>$y$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></li><li><p>Generate state diagram</p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.29.jpeg" alt="å›¾åƒ2024-11-23 23.29" style="zoom:33%;" /></li></ol><h2 id="Finite-State-Machine"><a href="#Finite-State-Machine" class="headerlink" title="Finite State Machine"></a>Finite State Machine</h2><p>A synchronous sequential circuit can be modeled by FSM.</p><p>State register $ğ‘(t+1) &#x3D; ğ‘_{next}(t)$<br>    Stores current state<br>    Loads next state at clock edge</p><p>Combinational logic<br>    Computes next state (next state logic $h: x Ã— ğ‘ â†’ ğ‘_{ğ‘›ğ‘’ğ‘¥ğ‘¡}$ )<br>    Computes outputs<br>        output logic $f: x Ã— ğ‘ â†’ ğ‘¦$ (Mealy machine, with blue line)<br>                or $f: ğ‘ â†’ ğ‘¦$ (Moore machine, without blue line)</p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.47.jpeg" alt="å›¾åƒ2024-11-23 23.47" style="zoom:33%;" /><p>Two types of finite state machines differ in output logic:<br>    Moore FSM: outputs depend only on current state<br>    Mealy FSM: outputs depend on current state and inputs, to synchronize a Mealy circuit, the inputs must be synchronized with the clock and the outputs must be sampled immediately before the clock edge</p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.56.jpeg" alt="å›¾åƒ2024-11-23 23.56" style="zoom:33%;" /><h2 id="State-Minimization-Encoding"><a href="#State-Minimization-Encoding" class="headerlink" title="State Minimization &amp; Encoding"></a>State Minimization &amp; Encoding</h2><h3 id="State-minimization"><a href="#State-minimization" class="headerlink" title="State minimization"></a>State minimization</h3><p>Reductions on the number of flip-flops (states) and the number of gates.<br>For an FSM with m states, we need $log_2m$ FFs.</p><p>Reduction steps</p><ol><li>Find rows in the state table that have identical next state and output entries. They correspond to equivalent states. If there are no equivalent states, stop.</li><li>When 2 states are equivalent, one of them can be removed. Update the entries of the remaining table to cancel the removed state. Go to 1.</li></ol><p>Example:<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2000.27.jpeg" alt="å›¾åƒ2024-11-24 00.27" style="zoom:50%;" /> $\longrightarrow$<img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2000.29.jpeg" alt="å›¾åƒ2024-11-24 00.29" style="zoom:50%;" /></p><p><strong>Start table:</strong></p><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td>d</td><td>e</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>e</u></td><td><u>a</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr><tr><td>f</td><td>g</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>g</u></td><td><u>a</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr></tbody></table><p><strong>1st turn:</strong> $e \equiv g$</p><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td><u>d</u></td><td><u>e</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr><tr><td>e</td><td>a</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>f</u></td><td><del>g</del>   <u>e</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr></tbody></table><p><strong>2nd turn:</strong> $d \equiv f$</p><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td>d</td><td>e</td><td><del>f</del>   d</td><td>0</td><td>1</td></tr><tr><td>e</td><td>a</td><td><del>f</del>   d</td><td>0</td><td>1</td></tr></tbody></table><h3 id="Encoding-assign-binary-state-to-the-states"><a href="#Encoding-assign-binary-state-to-the-states" class="headerlink" title="Encoding(assign binary state to the states)"></a>Encoding(assign binary state to the states)</h3><p>Different state encodings (assignments) result in different circuits for the intended FSM.<br>There is no easy state-encoding procedure that guarantees a minimal-cost or minimum-delay combinational circuits<br>    Exploration of all possibilities are impossible.<br>    Heuristic are often used.<br>        Binary counting<br>        Minimum-bit change<br>        One-hot encoding</p><h2 id="Design-of-Sequential-Circuits"><a href="#Design-of-Sequential-Circuits" class="headerlink" title="Design of Sequential Circuits"></a>Design of Sequential Circuits</h2><h3 id="Design-Procedure-of-Sequential-Circuits"><a href="#Design-Procedure-of-Sequential-Circuits" class="headerlink" title="Design Procedure of Sequential Circuits"></a>Design Procedure of Sequential Circuits</h3><ol><li>Specification: design description or timing diagram</li><li>Formulation: develop state diagram</li><li>Generate state and output tables</li><li>Minimize States if necessary</li><li>Assign binary values to the state (encoding)</li><li>Derive state and output equations</li><li><strong>Choose memory elements (DFFs, JKFFs, TFFs)</strong></li><li>Derive simplified excitation&#x2F;input equations and output equations</li><li>Draw logic schematic</li></ol><h3 id="Choice-of-Memory-Elements"><a href="#Choice-of-Memory-Elements" class="headerlink" title="Choice of Memory Elements"></a>Choice of Memory Elements</h3><p>Given the state transition table, we wish to find the FF input conditions that will cause the required transition.<br>    A tool for such a purpose is the excitation table, which can be derived from the characteristic table&#x2F;equation.<br>    D FFs are good for applications requiring data transfer (shift registers).<br>    T FFs are good for those involving complementation (binary counters).<br>    Many digital systems are constructed entirely with JK FFs because they are the most versatile available.</p><h3 id="FFâ€™s-Excitation-Table"><a href="#FFâ€™s-Excitation-Table" class="headerlink" title="FFâ€™s Excitation Table"></a>FFâ€™s Excitation Table</h3><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.51.jpeg" alt="å›¾åƒ2024-11-24 01.51" style="zoom:33%;" /><h3 id="Design-Example-Design-with-DFF-A-Sequence-Detector"><a href="#Design-Example-Design-with-DFF-A-Sequence-Detector" class="headerlink" title="Design Example: Design with DFF: A Sequence Detector"></a>Design Example: Design with DFF: A Sequence Detector</h3><ol><li><p>Detect three consecutive 1â€™s in a string of bits (using Moore machine, overlapping)<br> If detected, output&#x3D;1; otherwise output&#x3D;0</p></li><li><p>State diagram</p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.15.jpeg" alt="å›¾åƒ2024-11-24 01.15" style="zoom:33%;" /></li><li><p>State and output table</p><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td>$S(AB)$</td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td><td>$x&#x3D;0$</td><td>$x&#x3D;1$</td></tr><tr><td>$S_0 (00)$</td><td>$S_0$</td><td>$S_1$</td><td>0</td><td>0</td></tr><tr><td>$S_1(01)$</td><td>$S_0$</td><td>$S_2$</td><td>0</td><td>0</td></tr><tr><td>$S_2(10)$</td><td>$S_0$</td><td>$S_3$</td><td>0</td><td>0</td></tr><tr><td>$S_3(11)$</td><td>$S_0$</td><td>$S_3$</td><td>1</td><td>1</td></tr></tbody></table></li><li><p>No need for simplification</p></li><li><p>State assignment in 3</p></li><li><p>Derive state and output equations</p><table><thead><tr><th>$A(t)$</th><th>$B(t)$</th><th>$x$</th><th>$A(t+1)$</th><th>$B(t+1)$</th><th>$y$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p> $A(t+1)&#x3D;D_A(A(t),B(t),x)&#x3D;\Sigma(3,5,7)$<br> $B(t+1)&#x3D;D_B(A(t),B(t),x)&#x3D;\Sigma(1,5,7)$<br> $y(A,B,x)&#x3D;\Sigma(6,7)$</p></li><li><p>Choose DFFs<br> 2 bits encoding leads to 2 DFFs.<br> $A(t+1) &#x3D;D_A(t)$<br> $B(t+1)&#x3D;D_B(t)$</p></li><li><p>Derive simplified excitation&#x2F;input equations and output equations</p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.47.jpeg" alt="å›¾åƒ2024-11-24 01.47" style="zoom:40%;" /> $D_A=Ax+Bx$ $D_B=Ax+B'x$ $y=AB$</li><li><p>Logic schematic(Omitted)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital Logic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</title>
      <link href="/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/"/>
      <url>/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops"><a href="#Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops" class="headerlink" title="Digital Logic Chapter 5 part 1 - Latches and Flip-flops"></a>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</h1><h2 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h2><p>A sequential circuit consists of a combinational circuit to which storage elements are connected to form a feedback path.<br>The binary information stored in the memory elements at any given time defines the state of the sequential circuits.<br>$(inputs, current State)$ $\Longrightarrow$ $(outputs, next State)$, the behavior is specified by a time sequence of inputs and internal states.</p><h3 id="Synchronous-Sequential-Circuits"><a href="#Synchronous-Sequential-Circuits" class="headerlink" title="Synchronous Sequential Circuits"></a>Synchronous Sequential Circuits</h3><p>A system whose behavior can be defined from the knowledge of its signals at <strong>discrete</strong> instants of time.<br>Usually achieved by a timing device: clock generator, which means the outputs are affected only with the application of a clock pulse.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.04.jpeg"></p><h3 id="Asynchronous-Sequential-Circuits"><a href="#Asynchronous-Sequential-Circuits" class="headerlink" title="Asynchronous Sequential Circuits"></a>Asynchronous Sequential Circuits</h3><p>A system whose behavior depends upon input signals at <strong>any</strong> instant of time and the order in which the inputs change.<br>Commonly used storage devices are time-delay devices, and the propagation delay of the logic gates (time-delay devices) provides the required storage.<br>Can be viewed as combinational circuit with feedback, and can be unstable at times</p><h2 id="Storage-Elements"><a href="#Storage-Elements" class="headerlink" title="Storage Elements"></a>Storage Elements</h2><p>State: all the information about a circuit necessary to explain its future behavior </p><h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><h4 id="SR-Latch"><a href="#SR-Latch" class="headerlink" title="SR Latch"></a>SR Latch</h4><h5 id="SR-Latch-1"><a href="#SR-Latch-1" class="headerlink" title="SR Latch"></a>SR Latch</h5><p>It stores 1 bit of infomation, consists of two cross-coupled NOR gates or NAND gates.<br>Two input signals: $set(S)&#x2F;Reset(R)$<br>Two output signals: $Q&#x2F;Qâ€™$<br>Two useful states: $setState(Q&#x3D;1,Qâ€™&#x3D;0)&#x2F;resetState(Q&#x3D;0,Qâ€™&#x3D;1)$<br>Note: $Q$ and $Qâ€™$ should always be different. And $(S,R)$ should go back to $(0,0)$ before any other changes to avoid the occurrence of the undefined state.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.23.jpeg" style="zoom:28%;" /></p><p>Consider 4 possible cases:<br>1.$S&#x3D;1,R&#x3D;0$ $\Longrightarrow$ $Q&#x3D;1,Qâ€™&#x3D;0$ <strong>Set the output</strong>.<br>2.$S&#x3D;0,R&#x3D;1$ $\Longrightarrow$ $Q&#x3D;0,Qâ€™&#x3D;1$ <strong>Reset the output</strong>.<br>3.$S&#x3D;0,R&#x3D;0$ $\Longrightarrow$ $Q&#x3D;Q_{prev},Qâ€™&#x3D;Qâ€™_{prev}$ <strong>Memory function</strong>.<br>4.$S&#x3D;1,R&#x3D;1$ $\Longrightarrow$ $Q&#x3D;0,Qâ€™&#x3D;0$ <strong>Forbidden invalid state</strong>.</p><table><thead><tr><th align="left">$S$</th><th align="left">$R$</th><th>$Q$</th><th>$Qâ€™$</th><th>$State$</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>Memory</td></tr><tr><td align="left">0</td><td align="left">1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td align="left">1</td><td align="left">0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td align="left">1</td><td align="left">1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table><h5 id="Sâ€™Râ€™-Latch-with-NAND-gates"><a href="#Sâ€™Râ€™-Latch-with-NAND-gates" class="headerlink" title="Sâ€™Râ€™ Latch with NAND gates"></a>Sâ€™Râ€™ Latch with NAND gates</h5><p><strong>Low active</strong> Set&#x2F;Reset inputs<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.36.jpeg" style="zoom:25%;" /></p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Qâ€™$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>Forbidden</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>Memory</td></tr></tbody></table><h5 id="Clocked-SR-Latch"><a href="#Clocked-SR-Latch" class="headerlink" title="Clocked SR Latch"></a>Clocked SR Latch</h5><p>Use Clock (or En) to enable&#x2F;disable the SR latch<br>$C&#x3D;0$, no change(disabled)<br>$C&#x3D;1$, operates as normal SR latch (enabled)<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.42.jpeg" style="zoom:30%;" /></p><table><thead><tr><th>$C$</th><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Qâ€™$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>0</td><td>0</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>Memory</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table><h4 id="D-Latch"><a href="#D-Latch" class="headerlink" title="D Latch"></a>D Latch</h4><p>It stores 1 bit of infomation, constructed from a gated SR latch by connecting the D input to S input and Dâ€™ to R, which makes sure S and R are different in the SR Latch.<br>Two input signals: $Clock(clk&#x2F;En)&#x2F;Data(D)$<br>Two output signals: $Q&#x2F;Qâ€™$<br>Note: avoid invalid cases in SR Latches.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48.jpeg" alt="å›¾åƒ2024-11-22 10.48" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48%20(1).jpeg" alt="å›¾åƒ2024-11-22 10.48 (1)" style="zoom:38%;" /></p><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Qâ€™$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>no change(Memory)</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table><h3 id="Flip-flop"><a href="#Flip-flop" class="headerlink" title="Flip-flop"></a>Flip-flop</h3><h4 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h4><h5 id="Level-sensitive"><a href="#Level-sensitive" class="headerlink" title="Level sensitive"></a>Level sensitive</h5><p>The state transition starts as soon as the clock is during logic 1 (positive level-sensitive) or logic 0 (negative level-sensitive) level.</p><h5 id="Edge-triggered"><a href="#Edge-triggered" class="headerlink" title="Edge triggered"></a>Edge triggered</h5><p>The state transition starts only at positive (positive edge-triggered) or negative edge (negative edge-triggered) of the clock signal.</p><h4 id="D-Flip-flop"><a href="#D-Flip-flop" class="headerlink" title="D Flip-flop"></a>D Flip-flop</h4><h5 id="Standard-DFF-Properties"><a href="#Standard-DFF-Properties" class="headerlink" title="Standard DFF Properties"></a>Standard DFF Properties</h5><p>Inputs: $Clk$,$D$<br>A D flip-flop is formed by two separate latches:<br>A master D latch (negative level sensitive)<br>A slave D latch (positive level sensitive)<br>Positive-edge-triggered D flip-flop:<br>When $CLK &#x3D; 0$:<br>    master is transparent<br>    slave is opaque<br>    D passes through to P<br>When $CLK &#x3D; 1$<br>    master is opaque<br>    slave is transparent<br>    P passes through to Q<br>Thus, on the rising edge of the clock ($CLK$ rises from 0$\rightarrow$1)<br>    D passes through to Q<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2013.27.jpeg" alt="å›¾åƒ2024-11-22 13.27" style="zoom:25%;" /></p><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Qâ€™$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>X</td><td>$Q_{prev}$</td><td>$Qâ€™_{prev}$</td><td>no change</td></tr><tr><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>â†‘</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table><h5 id="Setup-time-and-hold-time"><a href="#Setup-time-and-hold-time" class="headerlink" title="Setup time and hold time"></a>Setup time and hold time</h5><p><strong>Setup time</strong><br>    D input must be maintained at a constant value prior to the application of the positive Clk pulse<br><strong>Hold time</strong><br>    Data input must not change after the application of the positive Clk pulse</p><h5 id="DFF-with-Reset"><a href="#DFF-with-Reset" class="headerlink" title="DFF with Reset"></a>DFF with Reset</h5><p>Active low reset<br>$Reset &#x3D; 0$: Q is forced to 0<br>$Reset &#x3D; 1$: flip-flop behaves as ordinary D flip-flop</p><table><thead><tr><th>$R$</th><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Qâ€™$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>0</td><td>1</td><td>Reset on power, forced $Q &#x3D; 0$</td></tr><tr><td>1</td><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>$\uparrow$</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2014.06.jpeg" alt="å›¾åƒ2024-11-22 14.06" style="zoom:40%;" /><p>The state of FFs are unknown when power is on. A direct input can force the FFs to a known state before the system starts.<br>    E.g. when $Reset &#x3D; 1$, FFâ€™s output is forced to 0<br>Synchronous vs. asynchronous resettable Flip Flop<br>    Asynchronous: resets immediately when $Reset &#x3D; 1$<br>    Synchronous: resets at the clock edge only</p><h4 id="J-K-Flip-flop"><a href="#J-K-Flip-flop" class="headerlink" title="J-K Flip-flop"></a>J-K Flip-flop</h4><p>e.g. <strong>Positive edge-triggered JKFF</strong></p><p>At rising edge of clock<br>$J &#x3D; K &#x3D; 0$, Q is unchanged<br>$J &#x3D; K &#x3D; 1$, Q toggles<br>$J &#x3D; 1, K &#x3D; 0$, Q is set to 1<br>$J &#x3D; 0, K &#x3D; 1$, Q is reset to 0<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="å›¾åƒ2024-11-22 16.01" style="zoom:33%;" /></p><p><strong>Characteristic equation:</strong><br>$$<br>Q(t+1)&#x3D; Jâ€™Kâ€™Q(t) + Jâ€™Kâ€¢0 + JKâ€™â€¢1 + JKQ(t)â€™<br>&#x3D; Jâ€™Kâ€™Q(t) + JKâ€™ + JKQ(t)â€™<br>&#x3D; Jâ€™Kâ€™Q(t) + JKâ€™Q(t) + JKâ€™Q(t)â€™ + JKQ(t)â€™<br>&#x3D; JQ(t)â€™ + Kâ€™Q(t)<br>$$<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.21.jpeg" alt="å›¾åƒ2024-11-22 16.21" style="zoom:33%;" /></p><h4 id="T-Flip-flop"><a href="#T-Flip-flop" class="headerlink" title="T Flip-flop"></a>T Flip-flop</h4><p>T: Toggle<br>$T &#x3D; 0$, a clock edge does not change the output.<br>$T &#x3D; 1$, a clock edge complements the output.<br>Useful for designing binary counters.</p><table><thead><tr><th>$T$</th><th>$Q_{next}$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>$Q$</td><td>no change</td></tr><tr><td>1</td><td>$Qâ€™$</td><td>take $Q$â€™s complement</td></tr></tbody></table><p><strong>Characteristic equation:</strong><br>$$<br>Q(t+1) &#x3D; Tâ€™Q(t) + TQ(t)â€™&#x3D; TâŠ•Q(t)<br>$$<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2021.03.jpeg" alt="å›¾åƒ2024-11-22 21.03" style="zoom:33%;" /></p><h3 id="Characteristic-Table"><a href="#Characteristic-Table" class="headerlink" title="Characteristic Table"></a>Characteristic Table</h3><p><strong>Characteristic table</strong>: describe the behavior of a flip-flop based on its input and current state Q(t) just before the rising edge of the clock, and the resulting next state Q(t+1) after the clock transition.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="å›¾åƒ2024-11-22 16.01" style="zoom:40%;" /></p><p><strong>Characteristic equation</strong>: derived from the Characteristic table, e.g. $Q_{t+1} &#x3D; D$</p><ol><li>From characteristic table to truth table</li><li>Algebrically or using K-map to get characteristic equation</li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital Logic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FirstPost</title>
      <link href="/2024/11/21/FirstPost/"/>
      <url>/2024/11/21/FirstPost/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
