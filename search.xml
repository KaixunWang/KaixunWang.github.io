<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Discrete Math Chapter 7 - Counting</title>
      <link href="/2024/11/26/Discrete%20Math%20Chapter%207:Counting/"/>
      <url>/2024/11/26/Discrete%20Math%20Chapter%207:Counting/</url>
      
        <content type="html"><![CDATA[<h1 id="Discrete-Math-Chapter-7-Counting"><a href="#Discrete-Math-Chapter-7-Counting" class="headerlink" title="Discrete Math Chapter 7 - Counting"></a>Discrete Math Chapter 7 - Counting</h1><h2 id="The-Counting-Basics"><a href="#The-Counting-Basics" class="headerlink" title="The Counting Basics"></a>The Counting Basics</h2><h3 id="The-Sum-Rule"><a href="#The-Sum-Rule" class="headerlink" title="The Sum Rule"></a>The Sum Rule</h3><p>A count decomposes into a set of independent counts.<br>    Elements of different counts are alternatives.</p><p><strong>Example</strong>: To travel from city A to B, you may either fly, or take a  train, or take a bus. There are 12 different flights, 5 different trains  and 10 different buses. How many options do you have to travel from A to B?</p><script type="math/tex; mode=display">12 + 5 + 10 = 27</script><p><strong>The Sum Rule</strong>: If a count of elements can be broken down into a set of independent counts, where the first count yields $n_1$ elements, the 2nd $n_2$ elements, and $k$th $n_k$ elements, then the  total number of elements is $n = n_1 + n_2 + … + n_k$ .</p><h3 id="The-Product-Rule"><a href="#The-Product-Rule" class="headerlink" title="The Product Rule"></a>The Product Rule</h3><p>A count decomposes into a sequence of dependent counts.<br>    Each element in one count is associated with all elements of the next count.</p><p><strong>Example</strong>: In an auditorium, the seats are labeled by a letter and numbers between 1 and 50 (e.g., A23). What is the total number of seats?</p><script type="math/tex; mode=display">26 × 50 = 1300</script><p><strong>The Product Rule</strong>: If a count of elements can be broken down into a sequence of dependent counts, where the first count yields $n_1$ elements, the 2nd $n_2$ elements, and $k$-th $n_k$ elements,  then the total number of elements is $n = n_1 × n_2 × … × n_k$ .</p><h3 id="Other-Rules"><a href="#Other-Rules" class="headerlink" title="Other Rules"></a>Other Rules</h3><h4 id="The-Subtraction-Rule"><a href="#The-Subtraction-Rule" class="headerlink" title="The Subtraction Rule"></a>The Subtraction Rule</h4><p>If a task can be done in $n_1$ or $n_2$ ways, then the number of ways to do the task is $n1 + n2$ minus the number of ways to do the task that are common to the two ways. E.g.,</p><script type="math/tex; mode=display">|A ∪ B| = |A| + |B| − |A ∩ B|</script><h4 id="The-Division-Rule"><a href="#The-Division-Rule" class="headerlink" title="The Division Rule"></a>The Division Rule</h4><p>If a task can be done using a procedure that can be carried out in n “<strong>fine-grained</strong>” ways, and every “giant”  way $w$ corresponds to exactly $d$ of the $n$ “<strong>fine-grained</strong>” ways,  then there are $n∕d$ “giant” ways to do it. E.g., how many kilobytes in one gigabyte?</p><script type="math/tex; mode=display">10^9 / 10^3 = 10^6</script><h4 id="More-Complex-Counting"><a href="#More-Complex-Counting" class="headerlink" title="More Complex Counting"></a>More Complex Counting</h4><p>Typically, a counting problem requires a combination of more than one rule. Example: Each password is 6 to 8 characters long, where each character is a lowercase letter or a digit. Each password must contain at least one digit. How many possible passwords are there?</p><script type="math/tex; mode=display">P = P_6 + P_7 + P_8</script><script type="math/tex; mode=display">P_6 = 36^6 – 26^6</script><script type="math/tex; mode=display">P_7 = 36^7 – 26^7</script><script type="math/tex; mode=display">P_8 = 36^8 – 26^8</script><h3 id="Tree-Diagram"><a href="#Tree-Diagram" class="headerlink" title="Tree Diagram"></a>Tree Diagram</h3><p>A tree is a structure that consists of a root, branches and leaves. It can represent a counting problem and record the choices we made for alternatives, with the possible outcomes on the leaves.</p><p>Example: What is the number of bit strings of length 4 that do not have consecutive 1s?</p><p><img src="../../../../../private/var/folders/08/w30jc0pj6_jcr0w4gj1_f7dh0000gn/T/com.apple.Photos.NSItemProvider/uuid=6873DE8E-1CB0-4B2F-ADA9-3DE23E26CE36&library=1&type=1&mode=1&loc=true&cap=true.jpeg/图像2024-11-26 01.49.jpeg" alt="图像2024-11-26 01.49" style="zoom:25%;" /></p><p>Example: The first team that wins 3 out of 5 games wins the playoff. In how many different ways can the playoff occur?</p><p><img src="../../../../../private/var/folders/08/w30jc0pj6_jcr0w4gj1_f7dh0000gn/T/com.apple.Photos.NSItemProvider/uuid=06729E94-9A5C-43F7-A432-0A37AF8B79FA&library=1&type=1&mode=1&loc=true&cap=true.jpeg/图像2024-11-26 01.50.jpeg" alt="图像2024-11-26 01.50" style="zoom:33%;" /></p><h3 id="The-Pigeonhole-Principle"><a href="#The-Pigeonhole-Principle" class="headerlink" title="The Pigeonhole Principle"></a>The Pigeonhole Principle</h3><p>If a flock of 13 pigeons flies into a set of 12 pigeonholes to roost, then at least one pigeonhole must have at least two pigeons in it.</p><p><strong>The Pigeonhole Principle</strong><br>If $k$ is a positive integer and $k + 1$ or more objects are placed into $k$ boxes, then there is at least one box containing two or more of the objects.<br>    proof by contradiction.</p><p><strong>The Generalized Pigeonhole Principle</strong><br>If $N$ objects are placed into $k$ boxes, then there is at least one box containing at least  $⌈N∕k⌉$ objects.<br>    proof by contradiction.</p><p><strong>Example</strong><br>We had 99 registered students in the beginning of this semester. At least how many of them were born in the same month?</p><script type="math/tex; mode=display">⌈99/12⌉ = 9</script><p>Now we have 96 students left. What about now?</p><script type="math/tex; mode=display">⌈96/12⌉ = 8</script><h3 id="Permutations-and-Combinations"><a href="#Permutations-and-Combinations" class="headerlink" title="Permutations and Combinations"></a>Permutations and Combinations</h3><p>Many counting problems can be solved by finding the number of ways to arrange or select some distinct elements from a set.</p><p>A <strong>permutation</strong> of a set of distinct objects is an <strong>ordered</strong> <strong>arrangement</strong> of these objects.<br>    • E.g., in how many ways can we select three students from a group of five students and arrange them to stand in line for a picture?</p><p>A <strong>combination</strong> of a set of distinct objects is an <strong>unordered</strong> <strong>selection</strong> of these objects.<br>    • E.g., how many different committees of three students can be formed from a group of five students?</p><h4 id="r-Permutations-and-r-Combinations"><a href="#r-Permutations-and-r-Combinations" class="headerlink" title="r-Permutations and r-Combinations"></a>r-Permutations and r-Combinations</h4><p>An ordered arrangement of $r$ distinct elements from a set of size $n$ is called a <strong>r-permutation</strong>.<br>    • An n-permutation of a set of size n is simply called a permutation.<br>Example: What are the 3-permutations of {1, 2, 3, 4}?</p><script type="math/tex; mode=display">L = {123, 124, 132, 134, 142, 143, 213, 214, 231, 234, 241, 243,312, 314, 321, 324, 341, 342, 412, 413, 421, 423, 431, 432}</script><p>​    • This type of “dictionary” ordering (where we treat numbers as  letters) is called a <strong>lexicographic ordering</strong> and is used quite often.</p><p>An unordered selection of $r$ distinct elements from a set of size $n$ is called a <strong>r-combination</strong>.<br>    Example: what are the 3-combinations of {1, 2, 3, 4}?</p><script type="math/tex; mode=display">L = {123, 124, 134, 234}</script><h5 id="r-Permutation"><a href="#r-Permutation" class="headerlink" title="r-Permutation"></a>r-Permutation</h5><p><strong>Theorem</strong>: Let $n, r$ be integers and $0 ≤ r ≤ n$, then there are $P(n, r) = n(n − 1)(n − 2) ··· (n − r + 1) = \dfrac {n!} {(n – r)!}$ r-permutations of a set with n distinct elements.<br>    • Note that $P(n, 0) = 1$, i.e., there is one way to order $0$ element</p><p><strong>Proof</strong>: There are n choices for the first number. For each way of choosing the first number, there are $n − 1$ choices for the second number.<br>    …<br>    For each way of choosing the first $r – 1$ numbers, there are $n − r + 1$ choices for the $r$-th number.<br>    Therefore, by the product rule, there are $n(n − 1)(n − 2) ··· (n − r + 1)$ r-permutations, which is equal to $\dfrac {n!} {(n – r)!}$ .</p><h5 id="r-Combination"><a href="#r-Combination" class="headerlink" title="r-Combination"></a>r-Combination</h5><p><strong>Theorem</strong>: Let $n, r$ be integers and $0 ≤ r ≤ n$, then there are $C(n, r) = P(n, r) / P(r, r) = \dfrac {n!}{r! (n – r)!}$  r-combinations of a set with n distinct elements.<br>    • Note that $C(n, 0) = 1$, i.e., there is one way to choose $0$ element</p><p>Proof: Since the order of elements in an $r$-combination does not matter and there are $P(r, r)$ different ways to order the $r$ elements in an $r$-combination<br>    each of the $C(n, r)$ $r$-combinations corresponds to exactly $P(r, r)$ r-permutations.<br>    Therefore, by the division rule, we have $C(n, r) = P(n, r) / P(r, r) = n! / r! (n – r)! $</p><h4 id="The-Birthday-Problem"><a href="#The-Birthday-Problem" class="headerlink" title="The Birthday Problem"></a>The Birthday Problem</h4><h5 id="The-Birthday-Paradox"><a href="#The-Birthday-Paradox" class="headerlink" title="The Birthday Paradox"></a>The Birthday Paradox</h5><p>Suppose that 23 students are in a room. What is the probability that at least two of them share a birthday?</p><p>​    • It’s greater than a <strong>half</strong>!</p><p>Assume a year has 365 days and there are no twins in the room. Calculate the probability as follows:<br>    • Sample space: $|S| = 365^n$ * all cases occur equally likely<br>        $A_n$ : “for $n$ students in a room $≥ 2$ of them share a birthday”<br>        $B_n$ : “for $n$ students in a room none of them share a birthday”</p><p>​        Number of $A_n=a$,</p><p>​        Number of $B_n=b=C(365,n)=365\times364\times…\times(365-(n-1))$</p><p>​        So, we have $a+b=|S|=365^n$</p><p>​        And $Pr[A_n]=\dfrac{a}{|S|}=1-\dfrac{b}{|S|}$</p><h5 id="The-Birthday-Attack"><a href="#The-Birthday-Attack" class="headerlink" title="The Birthday Attack"></a>The Birthday Attack</h5><p>In <strong>cryptography</strong>, the birthday attack is an attack that uses the probabilistic model shown in the birthday problem to reduce the  complexity of finding a collision for a hash function.<br>Assume a hash function has <strong>independent random outputs</strong>.<br>Each hash output can be viewed as a student’s birthday.</p><p>Q: What is the smallest number of inputs that we have to choose such that the probability of finding a hash collision is ≥ p?</p><p>Let $H$ be the number of possible hash outputs.<br>The collision probability when choosing $n$ random hash outputs is</p><script type="math/tex; mode=display">p(n;H):=1-\Pi^{n-1}_{i=1}(1-\dfrac{i}{H})</script><p>Since $e^x=1+x+\dfrac{x^2}{2!}+…$, for $|x|&lt;&lt;1$, $e^x \approx 1+x$</p><p>Thus, we have</p><script type="math/tex; mode=display">e^{\frac{-i}{H}} \approx 1-\dfrac{i}{H}</script><script type="math/tex; mode=display">p(n;H)\approx 1-e^{\frac{-n(n-1)}{2H}} \approx 1-e^{\frac{-n^2}{2H}}</script><p>By iterating, we have the smallest number $n$ :</p><script type="math/tex; mode=display">p(n;H)\approx \sqrt{2H\cdot ln\dfrac{1}{1-p}}</script><h2 id="Binomial-Coefficients-and-Identities"><a href="#Binomial-Coefficients-and-Identities" class="headerlink" title="Binomial Coefficients and Identities"></a>Binomial Coefficients and Identities</h2><h3 id="Binomial-Coefficients"><a href="#Binomial-Coefficients" class="headerlink" title="Binomial Coefficients"></a>Binomial Coefficients</h3><p>$Theorem$: For integers $n$ and $k$ with $0 ≤ k ≤ n$, the number of $k$-element subsets of an $n$-element set is</p><script type="math/tex; mode=display">\binom{n}{k}=C(n,k)=\dfrac{P(n,k)}{k!}=\dfrac{n!}{k!(n-k)!}</script><p><strong>Properties</strong>:</p><script type="math/tex; mode=display">\binom{n}{0}=\binom{n}{n}=1</script><script type="math/tex; mode=display">\binom{n}{k}=\binom{n}{n-k}</script><script type="math/tex; mode=display">\sum^n_{k=0}\binom{n}{k}=2^n</script><p><img src="../../../../../private/var/folders/08/w30jc0pj6_jcr0w4gj1_f7dh0000gn/T/com.apple.Photos.NSItemProvider/uuid=129504EF-5537-47D7-A26D-657B7C320F93&library=1&type=1&mode=1&loc=true&cap=true.jpeg/图像2024-11-26 20.09.jpeg" alt="图像2024-11-26 20.09" style="zoom:33%;" /></p><h3 id="Pascal’s-Triangle"><a href="#Pascal’s-Triangle" class="headerlink" title="Pascal’s Triangle"></a>Pascal’s Triangle</h3><p>Take the table and shift each row slightly such that middle element is in the center.</p><p><img src="../../../../../private/var/folders/08/w30jc0pj6_jcr0w4gj1_f7dh0000gn/T/com.apple.Photos.NSItemProvider/uuid=8CE21294-7A27-423E-A6DD-D3378D1B5D3E&library=1&type=1&mode=1&loc=true&cap=true.jpeg/图像2024-11-26 20.14.jpeg" alt="图像2024-11-26 20.14" style="zoom:25%;" /></p><p>Each <strong>(non-1)</strong> entry in Pascal’s triangle is the sum of the two entries directly above it.</p><p><strong>Pascal’s identity</strong>:</p><script type="math/tex; mode=display">\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}</script><p><strong>A Combinatorial Proof</strong>:</p><p>Let $S1$ be the set of all $k$-element subsets and $x_n$ be the $n$-th  element.</p><p>Partition $S1$ into $S2$ and $S3$ and apply the sum rule:</p><p>S2: the set of $k$-element subsets that contain $x_n$.</p><p>S3: the set of $k$-element subsets that <strong>don’t</strong> contain $x_n$.</p><script type="math/tex; mode=display">|S_1|=|S_2|+|S_3| \equiv \binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}</script><h3 id="The-Binomial-Theorem"><a href="#The-Binomial-Theorem" class="headerlink" title="The Binomial Theorem"></a>The Binomial Theorem</h3><p>Let $x$ and $y$ be variables, and let $n$ be a  nonnegative integer. Then</p><script type="math/tex; mode=display">\sum^n_{k=0}x^{n-k}y^k=(x+y)^n</script><p>Let $x=y=1$, we have $\sum^n_{k=0}\binom{n}{k}=2^n$</p><p>Let $x-1,y=-1$, we have $\sum^n_{k=0}(-1)^k\binom{n}{k}=0$</p><p>Let $y=1$, we have $\sum^n_{k=0}\binom{n}{k}x^k=(1+x)^n$</p><p><strong>Why the name “binomial coefficients”</strong>?</p><p>Because those numbers occur as coefficients in the expansion of powers of binomial expressions such as $(x + y)^n$</p><h3 id="Trinomial-Coefficients"><a href="#Trinomial-Coefficients" class="headerlink" title="Trinomial Coefficients"></a>Trinomial Coefficients</h3><p>What is the coefficient of $x^{k1}$ $y^{k2}$ $z^{k3}$ in $(x + y + z)^n$ ?</p><p>If we have $k_1$ red labels, $k_2$ blue labels, and $k_3 = n − k_1 − k_2$ purple labels, then in how many different ways can we apply  these labels to $n$ objects?</p><p>How many ways to choose the $k_1$ red items? How many ways to choose the $k_2$ blue items from the remaining $n − k_1$ items? Finally,  the remaining $k_3 = n – k_1 – k_2$ items get labelled purple.</p><script type="math/tex; mode=display">\binom{n}{k_1}\cdot \binom{n-k_1}{k_2}=\dfrac{n!}{k_1!(n-k_1)!} \cdot\dfrac{(n-k_1)!}{(k_2)!(n-k_1-k_2)!} =\dfrac{n!}{k_1!k_2!k_3!}</script><p>If $k_1 + k_2 + k_3 = n$, we call $\dfrac{n!}{k_1!k_2!k_3!}$ a trinomial coefficient and denote it as </p><script type="math/tex; mode=display">\binom{n}{k_1\ k_2\ k_3}</script><h2 id="Inclusion-Exclusion"><a href="#Inclusion-Exclusion" class="headerlink" title="Inclusion-Exclusion"></a>Inclusion-Exclusion</h2><h3 id="The-Inclusion-Exclusion-Principle"><a href="#The-Inclusion-Exclusion-Principle" class="headerlink" title="The Inclusion-Exclusion Principle"></a>The Inclusion-Exclusion Principle</h3><p>The principle is used in counts where the decomposition yields two dependent counting tasks with <strong>overlapping elements</strong><br>If we use the sum rule, some elements would be counted <strong>twice</strong>.</p><p>The principle uses the subtraction rule to correct for the overlapping elements after the sum.</p><p><strong>Two-set</strong> case:</p><script type="math/tex; mode=display">|A ∪ B| = |A| + |B| − |A ∩ B|</script><p><strong>Three-set</strong> case:</p><script type="math/tex; mode=display">|E ∪ F ∪ G| = |E| + |F| + |G| − |E ∩ F| − |E ∩ G| − |F ∩ G| + |E ∩ F ∩ G|</script><p>$E ∩ F, E ∩ G, F ∩ G$ got counted twice and then deducted once</p><p>$E ∩ F ∩ G$ got counted three times then deducted three times and finally got counted once</p><p><strong>The Principle of Inclusion-Exclusion</strong>: Let $E_1, E_2, …, E_n$ be <strong>finite</strong> sets, then</p><script type="math/tex; mode=display">|\cup^n_{i=1}E_i|=\sum^n_{k=1}(-1)^{k+1}\sum_{1\leq i_1<i_2<...<i_k \leq n}|E_{i1}\cap E_{i2} \cap... \cap E_{i_k}|</script><p>Proof by induction: omitted.</p><h3 id="The-Number-of-Onto-Functions"><a href="#The-Number-of-Onto-Functions" class="headerlink" title="The Number of Onto Functions"></a>The Number of Onto Functions</h3><p>We can use this principle to find the number of onto functions:</p><p>Let A, B be two sets with $|A| = m$ and $|B| = n$.</p><p>$number\  of\ (a)$ : the number of onto functions from A to B</p><p>$number\ of\ (b)$ : the number of non-onto functions from A to B, i.e., functions with at least one element of B having no preimage</p><p>Since there are $nm$ functions from A to B, we have $number\ of\ (a) + number\ of \ (b) = nm$.</p><p>So, in order to find $number\  of\ (a)$, we only need to calculate $number\  of\ (b)$.</p><p>Ei : set of functions such that the $i$-th element of B has no preimage</p><script type="math/tex; mode=display">number\  of\ (b)=|\cup^n_{i=1}E_i|</script><p>Consider any index list i1, i2, …, ik . How many such lists of size k? Functions in do not map to these k elements of B, so there are (n – k)m such functions in total. Therefore,</p><script type="math/tex; mode=display">number\  of\ (b)=|\cup^n_{i=1}E_i|=\sum^{n}_{k=1}(-1)^{k+1}\binom{n}{k}(n-k)^m</script><h2 id="Solving-Linear-Recurrence-Relations"><a href="#Solving-Linear-Recurrence-Relations" class="headerlink" title="Solving Linear Recurrence Relations"></a>Solving Linear Recurrence Relations</h2><h3 id="Linear-Recurrence-Relations"><a href="#Linear-Recurrence-Relations" class="headerlink" title="Linear Recurrence Relations"></a>Linear Recurrence Relations</h3><p>Definition: A linear homogeneous recurrence relation of degree k with constant coefficients is a recurrence relation of the form</p><script type="math/tex; mode=display">a_n = c_1 · a_{n−1} + c_2 · a_{n−2} + ··· + c_k · a_{n−k}</script><p>where $c_1, c_2, …, c_k$ are real numbers, and $c_k ≠ 0$.</p><p>linear: it is a linear combination of previous terms</p><p>homogeneous: all terms are multiples of $a_j$ s</p><p>degree $k$ : an is expressed by the previous k terms</p><p>constant coefficients: coefficients are constants</p><p>By induction, such a recurrence relation is uniquely determined by this recurrence relation, and $k$ initial conditions $a_0, a_1, …, a_k−1$.</p><h3 id="Solving-Recurrences-of-Degree-2"><a href="#Solving-Recurrences-of-Degree-2" class="headerlink" title="Solving Recurrences of Degree 2"></a>Solving Recurrences of Degree 2</h3><p>Consider an arbitrary linear homogeneous relation of degree 2 with constant coefficients:</p><script type="math/tex; mode=display">a_n = c_1 · a_{n−1} + c_2 · a_{n−2}</script><p>The characteristic equation (CE) is:</p><script type="math/tex; mode=display">r^2 − c_1 · r − c_2 = 0</script><p><strong>Theorem</strong>:</p><p>If this CE has two <strong>distinct</strong> roots $r1, r2$, then a sequence ${an}$ is a solution of the recurrence relation if and only if </p><script type="math/tex; mode=display">a_n = α_1 · r_1 n + α_2 · r_2 n\ \forall n ≥ 0,</script><p>where $α_1, α_2$ are constants</p><h3 id="Solving-Recurrences-of-Degree-k"><a href="#Solving-Recurrences-of-Degree-k" class="headerlink" title="Solving Recurrences of Degree k"></a>Solving Recurrences of Degree k</h3><p>Consider an arbitrary linear homogeneous relation of degree k with constant coefficients:</p><script type="math/tex; mode=display">a_n = c_1 · a_{n−1} + c_2 · a_{n−2} + ··· + c_k · a_{n−k}</script><p>The characteristic equation (CE) is:  </p><script type="math/tex; mode=display">r^k − c_1 · r^{k–1} − c_2 · r ^{k–2} − ··· − c_k = 0</script><p><strong>Theorem</strong>: </p><p>If this CE has $k$ <strong>distinct</strong> roots $r_1, r_2 , ···, r_k$ , then the solutions to the above recurrence is of the form $a_n = α_1 · r_1^n + α_2 · r_2^n + ··· + α_k · r_k^n$ for $n ≥ 0$, where $α1, α2, …, αk$ are constants. </p><h3 id="The-Case-of-Degenerate-Roots"><a href="#The-Case-of-Degenerate-Roots" class="headerlink" title="The Case of Degenerate Roots"></a>The Case of Degenerate Roots</h3><p><strong>Theorem</strong>:</p><p>If the CE $r^2 − c_1 · r − c2 = 0$ has only one root $r_0$ (i.e., with multiplicity 2), then</p><script type="math/tex; mode=display">a_n = (α_1 + α_2 · n) r_0^n = α_1 · r_0^n + α_2 · n · r_0^n</script><p>for $n ≥ 0$,  where $α1, α2$ are constants. </p><p><strong>Theorem</strong>:</p><p>Suppose the CE $r^k − c_1 · r^(k–1) − ··· − c_k = 0$ has $t$ distinct roots $r_1, …, r_t$ with multiplicities (重数) $m_1, …, m_t$ respectively</p><p>Where $m_i\geq1, m_1 + ··· + m_t = k$.</p><p>Then for $n ≥ 0$, where $α_{i,j}$ are constants.</p><script type="math/tex; mode=display">a_n=\sum^t_{i=1}(\sum^{m_i-1}_{j=0}a_{i,j}\cdot n^j)r^n_i</script><h3 id="Solving-Nonhomogeneous-Recurrences"><a href="#Solving-Nonhomogeneous-Recurrences" class="headerlink" title="Solving Nonhomogeneous Recurrences"></a>Solving Nonhomogeneous Recurrences</h3><p>Theorem: If $a_n = p(n)$ is any particular solution to the <strong>linear</strong> <strong>nonhomogeneous</strong> relation with constant coefficients</p><script type="math/tex; mode=display">a_n = c_1 · a_{n−1} + c_2 · a_{n−2} + ··· + c_k · a_{n−k} + F(n)</script><p>Then all its solutions are of the form $a_n = p(n) + h(n)$</p><p>where $a_n = h(n)$ is any solution to the associated <strong>homogeneous</strong> recurrence relation</p><script type="math/tex; mode=display">a_n = c_1 · a_{n−1} + c_2 · a{n_2} + ··· + c_k · a_{n−k}</script><h2 id="Generating-Functions"><a href="#Generating-Functions" class="headerlink" title="Generating Functions"></a>Generating Functions</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>The generating function for the sequence ${ak}$ of real numbers is the infinite series</p><script type="math/tex; mode=display">G(x)=a_0+a_1x+...+a_kx^k+...=\sum^\infty_{k=0}a_kx^k</script><p>Geometric seires sum:</p><script type="math/tex; mode=display">S_n=a\dfrac{1-r^n}{1-r}</script><p>We use generating functions to characterize sequences:</p><p>$\sum^\infty_{k=0}3x^k$ is the generating function for the sequence ${a_k}$ with $a_k = 3$</p><script type="math/tex; mode=display">\sum^\infty_{k=0}3x^k={\lim_{x \to \infty}}\sum^n_{k=0}3x^k=3{\lim_{x \to \infty}}\dfrac{1-x^{n+1}}{1-x}=\dfrac{3}{1-x},\ for\ |x|<1</script><p>$\sum^\infty_{k=0}2^kx^k$ is the generating function for the sequence ${a_k}$ with $a_k = 2^k$</p><script type="math/tex; mode=display">\sum^\infty_{k=0}2^kx^k={\lim_{x \to \infty}}\sum^n_{k=0}(2x)^k={\lim_{x \to \infty}}\dfrac{1-(2x)^{n+1}}{1-2x}=\dfrac{1}{1-2x},\ for\ |2x|<1</script><h3 id="Operations-of-Generating-Functions"><a href="#Operations-of-Generating-Functions" class="headerlink" title="Operations of Generating Functions"></a>Operations of Generating Functions</h3><p>Let $f(x)=\sum^{\infty}<em>{k=0}a_kx^k$ and $g(x)=\sum^{\infty}</em>{k=0}b_kx^k$</p><script type="math/tex; mode=display">f(x)+g(x)=\sum^{\infty}_{k=0}(a_k+b_k)x^k</script><script type="math/tex; mode=display">f(x)g(x)=\sum^{\infty}_{k=0}(\sum^{k}_{j=0}a_jb_{k-j})x^k</script><h3 id="The-Case-of-Finite-Sequences"><a href="#The-Case-of-Finite-Sequences" class="headerlink" title="The Case of Finite Sequences"></a>The Case of Finite Sequences</h3><p>Definition: The generating function for the finite sequence $a_0, a_1, …$, an of real numbers is a polynomial of degree $n$</p><script type="math/tex; mode=display">G(x)=a_0+a_1x+a_2x^2+...+a_nx^n</script><p>A finite sequence $a<em>0, a_1, …, a_n$ can be easily extended to infinity by setting $a</em>{n+1} = a_{n+2} = ··· = 0$</p><h3 id="Useful-Generating-Functions"><a href="#Useful-Generating-Functions" class="headerlink" title="Useful Generating Functions"></a>Useful Generating Functions</h3><script type="math/tex; mode=display">(1+x)^n=\sum^n_{k=0}C(n,k)x^k</script><script type="math/tex; mode=display">(1+ax)^n=\sum^n_{k=0}C(n,k)(ax)^k</script><script type="math/tex; mode=display">(1+x^r)^n=\sum^n_{k=0}C(n,k)x^{rk}</script><script type="math/tex; mode=display">\dfrac{1-x^{n+1}}{1-x}=\sum^n_{k=0}x^k=1+x+...+x^n</script><script type="math/tex; mode=display">\dfrac{1}{1-x}=\sum^{\infty}_{k=0}x^k=1+x+...</script><script type="math/tex; mode=display">\dfrac{1}{1-ax}=\sum^{\infty}_{k=0}a^kx^k=a+ax+a^2x^2+...</script><script type="math/tex; mode=display">\dfrac{1}{1-x^r}=\sum^\infty_{k=0}x^{rk}=1=1+x^r+x^{2r}+...</script><script type="math/tex; mode=display">\dfrac{1}{(1-x)^2}=\sum^\infty_{k=0}(k+1)x^k=1+2x+3x^2+...</script><script type="math/tex; mode=display">\dfrac{1}{(1-x)^n}=\sum^\infty_{k=0}C(n+k-1,k)x^k</script><script type="math/tex; mode=display">\dfrac{1}{(1+x)^n}=\sum^\infty_{k=0}C(n+k-1,k)(-1)^kx^k</script><script type="math/tex; mode=display">\dfrac{1}{(1-ax)^n}=\sum^\infty_{k=0}C(n+k-1,k)a^kx^k</script><script type="math/tex; mode=display">e^x=\sum^\infty_{k=0}\dfrac{x^k}{k!}=1+x+\dfrac{x^2}{2!}+...</script><script type="math/tex; mode=display">ln(1+x)=\sum^\infty_{k=0}\dfrac{(-1)^{k+1}x^k}{k}=x-\dfrac{x^2}{2}+\dfrac{x^3}{3}-...</script><h3 id="Solving-Recurrences-with-G-x"><a href="#Solving-Recurrences-with-G-x" class="headerlink" title="Solving Recurrences with $G(x)$"></a>Solving Recurrences with $G(x)$</h3><p>Using generating functions to solve recurrence relations:</p><p>Step 1: Based on the given recurrence and its initial conditions, find  its generating function $G(x)$ as an explicit formula.</p><p>Step 2: Rewrite $G(x)$ as the summation of an infinite (or finite) series.</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="1-Answer-the-following-questions"><a href="#1-Answer-the-following-questions" class="headerlink" title="1. Answer the following questions:"></a>1. Answer the following questions:</h3><p>How many different bit strings of length 7 are there?</p><script type="math/tex; mode=display">2^7</script><p>How many different functions from a set with $m$ elements to a set with $n$ elements?</p><script type="math/tex; mode=display">n^m</script><p>How many injective functions from a set with $m$ elements to a set with $n$ elements ($m ≤ n$)?</p><p>put $m$ elements to $n$ place $\longrightarrow $ $P(n,m)=\dfrac{n!}{(n-m)!}$</p><p>How many onto functions from a set with $m$ elements to a set with  $n$ elements ($m ≥ n$)?</p><script type="math/tex; mode=display">n^m – C(n, 1)(n – 1)^m + C(n, 2)(n – 2)^m – ··· + (–1)^{n-1}C(n, n – 1)1^m</script><h3 id="2-How-many-bit-strings-of-length-8-that-start-with-a-‘1’-bit-or-end-with-the-two-bits-‘00’"><a href="#2-How-many-bit-strings-of-length-8-that-start-with-a-‘1’-bit-or-end-with-the-two-bits-‘00’" class="headerlink" title="2. How many bit strings of length 8 that start with a ‘1’ bit  or end with the two bits ‘00’?"></a>2. How many bit strings of length 8 that start with a ‘1’ bit  or end with the two bits ‘00’?</h3><p>It is easy to count bit strings starting with ‘1’: $2^7$</p><p>It is easy to count bit strings ending with ‘00’: $2^6$</p><p>Deduct the overcounted number of strings starting with ‘1’ and ending with ‘00’: $2^5$</p><h3 id="3-Are-these-linear-homogeneous-recurrence-relations"><a href="#3-Are-these-linear-homogeneous-recurrence-relations" class="headerlink" title="3. Are these linear homogeneous recurrence relations?"></a>3. Are these linear homogeneous recurrence relations?</h3><script type="math/tex; mode=display">P_n = P_{n−1}</script><p>Yes, of degree $1$</p><script type="math/tex; mode=display">f_n = f_{n−1} + f_{n−2}</script><p>Yes, of degree $2$</p><script type="math/tex; mode=display">a_n = a_{n−1} + a_{n–2} · a_{n–2}</script><p>No, not linear</p><script type="math/tex; mode=display">H_n = 2H_{n−1} + 1</script><p>No, not homogeneous</p><script type="math/tex; mode=display">B_n = nB_{n−1}</script><p>Yes, but coefficients are not constants</p><h3 id="4-Solve-the-recurrence"><a href="#4-Solve-the-recurrence" class="headerlink" title="4. Solve the recurrence:"></a>4. Solve the recurrence:</h3><script type="math/tex; mode=display">a_n = 7a_{n−1} − 10a_{n−2}</script><p>With $a_0 = 2, a_1 = 1$ .</p><p>The characteristic equation (CE) is</p><script type="math/tex; mode=display">r^2 − 7r + 10 = 0</script><p>Two roots are $2$ and $5$. So, assume that $a_n = α_1 · 2^n + α_2 · 5^n$</p><p>By the two initial conditions, we have </p><script type="math/tex; mode=display">a_0 = α_1 + α_2 = 2</script><script type="math/tex; mode=display">a_1 = 2α_1 + 5α_2 = 1</script><p>We get $α_1 = 3$ and $α_2 = −1$.</p><p>Therefore $a_n = 3 · 2^n − 5^n$</p><h3 id="5-What-is-the-closed-form-expression-of-Fibonacci-sequence-F-n"><a href="#5-What-is-the-closed-form-expression-of-Fibonacci-sequence-F-n" class="headerlink" title="5. What is the closed-form expression of Fibonacci sequence $F_n$ ?"></a>5. What is the closed-form expression of Fibonacci sequence $F_n$ ?</h3><script type="math/tex; mode=display">F_0 = 0, F_1 = 1\ and\ F_n = F_{n−1} + F_{n−2}\ for\ n ≥ 2</script><p>Consider the characteristic equation (CE): $x^2 – x + 1 = 0$. There are  two different roots</p><script type="math/tex; mode=display">r_1=\dfrac{1+\sqrt{5}}{2},r_2=\dfrac{1-\sqrt{5}}{2}</script><script type="math/tex; mode=display">F_n=α_1 ⋅r_1^n + α_2 ⋅ r_2^n</script><script type="math/tex; mode=display">F_0=0,F_1=1 \longrightarrow α_1 = \dfrac{1}{\sqrt{5}},α_2 = -\dfrac{1}{\sqrt{5}}</script><script type="math/tex; mode=display">F_n=\dfrac{r_1^n-r_2^n}{\sqrt{5}}</script><h3 id="6-Solve-the-recurrence"><a href="#6-Solve-the-recurrence" class="headerlink" title="6. Solve the recurrence:"></a>6. Solve the recurrence:</h3><script type="math/tex; mode=display">a_n = 4a_{n-1} − 4a_{n-2}</script><p>with $a_0 = 1, a_1 = 0$</p><p>CE: $x^2=4x-4$</p><p>Root: $r=2$ with multiplicity 2</p><script type="math/tex; mode=display">a_n=(\alpha_1+\alpha_2*n)r^n</script><script type="math/tex; mode=display">a_0=a_1=1,a_1=2\alpha_1+2\alpha_2\ \longrightarrow\ \alpha_1=1,\alpha_2=-1</script><script type="math/tex; mode=display">a_n=2^n-n2^n</script><h3 id="7-Solve-the-recurrence"><a href="#7-Solve-the-recurrence" class="headerlink" title="7. Solve the recurrence:"></a>7. Solve the recurrence:</h3><script type="math/tex; mode=display">a_n = 3a_{n−1} + 2n</script><p>with $a_1 = 3$</p><p>The characteristic equation (CE) of the associated linear homogeneous recurrence relation is</p><script type="math/tex; mode=display">r − 3 = 0</script><p>The root is 3. So, assume an = p(n) is a particular solution to the original recurrence relation, then all of its solutions are of the form</p><script type="math/tex; mode=display">a_n = α_1 · 3^n + p(n)</script><p>It is natural to try a degree-1 polynomial, i.e., $p(n) = cn + d$. Then,</p><script type="math/tex; mode=display">\begin{align*}     cn + d &=3(c(n – 1) + d) + 2n \\ &=(2c + 2)n + 2d – 3c\end{align*}</script><p>We have $c =(2c+2),d=2d-3c$</p><p>We get $c = –1$ and $d = −3/2$.</p><p>Therefore, $a_n = α_1 · 3^n − n − \dfrac{3}{2}$.</p><p>By the initial condition $a_1 = 3α_1 − 1 − 3/2 = 3$, we get $α_1 = 11/6$.</p><h3 id="8-Solve"><a href="#8-Solve" class="headerlink" title="8. Solve"></a>8. Solve</h3><script type="math/tex; mode=display">a_k = 5a_{k-1} – 6a_{k-2},(k ≥ 2)</script><p>with $a_0 = 6, a_1 = 30$</p><p>Let $G(x)$ be the generating function of $a_k$</p><script type="math/tex; mode=display">G(x)=\sum^\infty_{k=0}a_kx^k</script><p>Multiply both side with $x^k$ and sum over $k\geq 2$</p><script type="math/tex; mode=display">\sum^\infty_{k=2}a_kx^k=5\sum^\infty_{k=2}a_{k-1}x^k-6\sum^\infty_{k=2}a_{k-2}x^k</script><p>For the LHS, $\sum^\infty_{k=2}a_kx^k=G(x)-a_0-a_1$</p><p>For the RHS, </p><script type="math/tex; mode=display">\sum^\infty_{k=2}a_{k-1}x^k=\sum^\infty_{k=1}a_{k}x^{k+1}=x(G(x)-a_0)</script><script type="math/tex; mode=display">\sum^\infty_{k=2}a_{k-2}x^k=\sum^\infty_{k=0}a_kx^{k+2}=x^2G(x)</script><p>We have</p><script type="math/tex; mode=display">G(x)-a_0-a_1x=5xG(x)-5xa_0-6x^2G(x)</script><script type="math/tex; mode=display">(6x^2-5x+1)G(x)=6</script><script type="math/tex; mode=display">G(x)=\dfrac{6}{(3x-1)(2x-1)}=\dfrac{A}{3x-1}+\dfrac{B}{2x-1}</script><script type="math/tex; mode=display">A(2x-1)+B(3x-1)=-(A+B)+(2A+3B)x=6</script><script type="math/tex; mode=display">A+B=-6,2A+3B=0\ \longrightarrow\ A=-18,B=12</script><script type="math/tex; mode=display">G(x)=18\dfrac{1}{1-3x}-12\dfrac{1}{1-2x}=18\sum^\infty_{k=0}3^kx^k-12\sum^\infty_{k=0}2^kx^k=\sum^\infty_{k=0}(18\cdot3^k-12\cdot2^k)x^k</script><script type="math/tex; mode=display">a_k=18\cdot 3^k-12\cdot2^k</script>]]></content>
      
      
      <categories>
          
          <category> Discrete Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discrete Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discrete Math Chapter 6 - Induction and Recursion</title>
      <link href="/2024/11/24/Discrete%20Math%20Chapter%206:Induction%20and%20Recursion/"/>
      <url>/2024/11/24/Discrete%20Math%20Chapter%206:Induction%20and%20Recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="Discrete-Math-Chapter-6-Induction-and-Recursion"><a href="#Discrete-Math-Chapter-6-Induction-and-Recursion" class="headerlink" title="Discrete Math Chapter 6 - Induction and Recursion"></a>Discrete Math Chapter 6 - Induction and Recursion</h1><h2 id="Mathematical-Induction"><a href="#Mathematical-Induction" class="headerlink" title="Mathematical Induction"></a>Mathematical Induction</h2><h3 id="Principle-of-Mathematical-Induction"><a href="#Principle-of-Mathematical-Induction" class="headerlink" title="Principle of Mathematical Induction"></a>Principle of Mathematical Induction</h3><p>Let $P(n)$ be a <strong>predicate</strong>. i.e., $P(n)$ is either true or false when $n$ is a specific number.<br><strong>Principle of Mathematical Induction</strong>: To prove that $P(n)$ is true for all positive integers $n \in Z^+$, we complete 2 steps:<br>    <strong>Basic step</strong>: prove $P(1)$ is <strong>true</strong>;<br>    <strong>Inductive step</strong>: prove $\forall k \in Z^+,P(k) \rightarrow P(k+1)$ is <strong>true</strong>.<br>    (“$P(k)$ is ture” is called the <strong>inductive hypothesis</strong> (<strong><em>IH</em></strong>)归纳假设)</p><p><strong>Why this principle is valid?</strong><br>Proof by contradiction: Assume $P(n)$ is false for some integer $n ≥ 1$, then the set $S$ of all positive integer n such that $P(n)$ is false is not empty. Let m be the smallest integer in $S$.<br><strong>Why such m exists?</strong><br>We have $m ≥ 2$ as $P(1)$ is true. However, since $P(m – 1)$ is true and $P(m – 1) → P(m)$ is true, $P(m)$ must be true, contradiction!</p><h3 id="Well-Ordering-Principle"><a href="#Well-Ordering-Principle" class="headerlink" title="Well-Ordering Principle"></a>Well-Ordering Principle</h3><p><strong>Well-Ordering Principle</strong>: every nonempty subset of $Z^+$ has a least/minimum element $\longrightarrow$ this is an <strong>axiom</strong>.<br>This principle is <strong>equivalent</strong> to mathematical induction.</p><p>This also means mathematical induction can be generalized from $Z^+$ to <strong>any well-ordered</strong> set $S$, e.g., $N, {n \in Z | n \geq b}$, etc.</p><h3 id="Another-Form-of-Induction"><a href="#Another-Form-of-Induction" class="headerlink" title="Another Form of Induction"></a>Another Form of Induction</h3><p>Consider another form of mathematical induction as follows:<br><strong>First</strong> suppose that we have a proof that $P(1)$ is true.<br><strong>Next</strong> suppose that we have a proof that $∀k ≥ 1, P(1) ∧ P(2) ∧ ··· ∧ P(k) → P(k + 1)$<br>Then, $P(1) → P(2) P(1) ∧ P(2) → P(3) P(1) ∧ P(2) ∧ P(3) → P(4) …$<br>Iterating gives us a proof of $P(n)$ for all $n$.</p><h3 id="Strong-Induction"><a href="#Strong-Induction" class="headerlink" title="Strong Induction"></a>Strong Induction</h3><p><strong>Second principle of mathematical induction</strong>: To prove that $P(n)$ is true for all positive integers $n$, we complete two steps:<br>    Basis step: prove $P(1)$ is true<br>    Inductive step: prove $∀k ∈ Z+ , P(1) ∧ ··· ∧ P(k) → P(k + 1)$ is true<br>    (here “$P(1) ∧ P(2) ∧ ··· ∧ P(k)$ is true” is the <strong>inductive hypothesis</strong> (IH))</p><p>This is called <strong>strong induction</strong> or <strong>complete induction</strong>, while the previous principle is called <strong>weak</strong> or <strong>incomplete induction</strong>.<br>In practice, strong induction is often <strong>easier</strong> to apply than its weak form, because the inductive hypothesis is stronger.<br>However, these two forms of induction are actually <strong>equivalent</strong>.</p><h3 id="Core-idea"><a href="#Core-idea" class="headerlink" title="Core idea"></a>Core idea</h3><p>The assumption “$P(k)$ is true” <strong>OR</strong> “$P(1) ∧ P(2) ∧ ··· ∧ P(k)$ is true” is called the <strong>inductive hypothesis</strong> (IH).<br>IH is used as <strong>premises</strong> to prove the conclusion “$P(k + 1)$ is true” .</p><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><strong>Recursion</strong>: a method of solving a computational problem where its solution depends on <strong>solutions to smaller instances</strong> of the same problem.<br>Recursive computer programs or algorithms often lead to <strong>inductive analysis</strong>.<br>A classical example of recursion is the <strong>Towers of Hanoi puzzle</strong>.</p><h3 id="Towers-of-Hanoi-Puzzle"><a href="#Towers-of-Hanoi-Puzzle" class="headerlink" title="Towers of Hanoi Puzzle"></a>Towers of Hanoi Puzzle</h3><p>Problem: Find an efficient way to move all of the disks from <strong>one peg to another</strong>, using only <strong>legal moves</strong>.<br>Consider 3 pegs and $n$ disks of different sizes.<br><strong>A legal move</strong> takes a disk from one peg and moves it onto another peg so that it is <strong>not on top of a smaller disk</strong>.</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h4><p>Solution by recursion: very similar to mathematical induction<br>    <strong>Basis step</strong>: If n = 1, moving one disk from one to another is easy.<br>    <strong>Recursive step</strong>: If n &gt; 1, we need 3 steps (e.g., to move n disks from peg 1 to peg 3):<br>        1)n – 1 from 1 to 2<br>        2)largest from 1 to 3<br>        3)n – 1 from 2 to 3</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-25%2002.00.jpeg" alt="图像2024-11-25 02.00" style="zoom:25%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hanoi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123; <span class="comment">//move n disks from peg a to peg c using peg b</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;plate&quot;</span> + n + <span class="string">&quot; from &quot;</span> + a + <span class="string">&quot; to &quot;</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            move(n - <span class="number">1</span>, a, c, b); <span class="comment">//move n-1 disks from a to b using c</span></span><br><span class="line">            System.out.println(<span class="string">&quot;plate&quot;</span> + n + <span class="string">&quot; from &quot;</span> + a + <span class="string">&quot; to &quot;</span> + c); <span class="comment">//move the largest disk from a to c</span></span><br><span class="line">            move(n - <span class="number">1</span>, b, a, c); <span class="comment">//move n-1 disks from b to c using a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Proof-of-correctness-of-solution-by-induction"><a href="#Proof-of-correctness-of-solution-by-induction" class="headerlink" title="Proof of correctness (of solution) by induction:"></a><strong>Proof of correctness (of solution) by induction</strong>:</h4><p>Let $P(n)$ be the predicate that the solution is correct for $n$.<br>Basis step: $P(1)$ is obviously true, i.e., the solution is correct when there is only one disk.<br>Inductive step: From the inductive hypothesis, i.e., $P(k)$ is true for an arbitrary positive integer $k$, we need to show that $P(k + 1)$ is true. That is, if our solution works for $k$ disks, then we can build a correct solution for $k + 1$ disks, which is true by the recursive step:</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-25%2002.10.jpeg" alt="图像2024-11-25 02.10" style="zoom:50%;" /></p><h4 id="Running-Time"><a href="#Running-Time" class="headerlink" title="Running Time"></a><strong>Running Time</strong></h4><p>Let $M(n)$ be the number of disk moves.<br>    <strong>Basic step</strong>: If $n=1$, moving one time only, $M(1)=1$ obviously.<br>    <strong>Recursive step</strong>: If $n&gt;1$, we need three steps, $M(n) = 2M(n-1)+1$ for $n&gt;1$<br>We can guess $M(n)=2^n-1$, proof using <strong>mathematical induction</strong>, thus omitted.</p><h2 id="Recurrence-Relations"><a href="#Recurrence-Relations" class="headerlink" title="Recurrence Relations"></a>Recurrence Relations</h2><p>A recurrence relation or recurrence for a function defined on the set of $integers ≥ b$ tells us how to compute the $nth$ value from some or all of the first $n – 1$ values.<br>To completely specify a function defined by a recurrence, we have to also give the <strong>initial condition(s)</strong> (as known as the <strong>base case(s)</strong>) for the recurrence.<br>Example: running time for Towers of Hanoi</p><script type="math/tex; mode=display">M(n)= \begin{cases} 1& \text{$n=1$}\\ 2M(n-1)+1& \text{$otherwise$} \end{cases}</script><h3 id="Iterating-a-Recurrence"><a href="#Iterating-a-Recurrence" class="headerlink" title="Iterating a Recurrence"></a>Iterating a Recurrence</h3><p>Let $T(n) = rT(n − 1) + a$, where $r$ and $a$ are constants.<br><strong>Find a recurrence relation that expresses</strong><br>    $T(n)$ in terms of $T(n − 2)$<br>    $T(n)$ in terms of $T(n − 3)$<br>    $T(n)$ in terms of $T(n − 4)$<br>    …<br>Can we generalize this to find a <strong>closed-form solution</strong> to $T(n)$?<br>Note that $T(n) = rT(n − 1) + a$ implies that $\forall (n – i) &gt; 0$: $T(n − i) = rT((n − i) − 1)) + a$<br>        $T(n)=rT(n-1)+a=r^2T(n-2)+ra+a=r^3T(n-3)+r^2a+ra+a=…$<br>        Guess: $T(n)=r^nT(0)+a\sum^{n-1}_{i=0}r^i$<br>The technique we used to guess the closed formula of $T(n)$ is called iteration, because we iteratively use the recurrence.<br>The approach we just used is called backward substitution, because we began with $T(n)$ and iterated to express it in terms of falling terms of the sequence until we found it in terms of $T(0)$.</p><h3 id="Closed-Formula-of-Recurrences"><a href="#Closed-Formula-of-Recurrences" class="headerlink" title="Closed Formula of Recurrences"></a>Closed Formula of Recurrences</h3><p>Theorem: If $T(n) = rT(n − 1) + a, T(0) = b$, and $r ≠ 1$, then for all non-negative integers $n$, we have:</p><p>​                                $T(n)=r^nb+a\dfrac{1-r^n}{1-r}$</p><p><strong>Proof by induction</strong>:<br>    <strong>Basis step</strong>: The formula is true for n = 0: $T(0)=r^0b+a\dfrac{1-r^0}{1-r}=b$<br>    <strong>Inductive step</strong>:$T(n) = rT(n-1)+a=r(r^{n-1}b+a\dfrac{1-r^{n-1}}{1-r})=r^nb+\dfrac{ar-ar^n+a+ar}{1-r}=r^nb+a\dfrac{1-r^n}{1-r}$</p><h3 id="First-Order-Linear-Recurrences"><a href="#First-Order-Linear-Recurrences" class="headerlink" title="First Order Linear Recurrences"></a>First Order Linear Recurrences</h3><p>Theorem: For any constants $a$ and $r ≠ 0$, and any function $g$ defined on positive integers, the solution to the recurrence</p><script type="math/tex; mode=display">T(n)= \begin{cases} a& \text{$n=0$}\\ rT(n-1)+g(n)& \text{$n>0$} \end{cases}</script><p>We have $T(n)=r^na+\sum^{n}_{i=1}r^{n-i}g(i)$</p><p>A recurrence relation of the form $T(n) = f(n)T(n − 1) + g(n)$ is called  a first-order linear recurrence.<br>    <strong>First order</strong>: $T(n)$ depends upon going back one step, i.e., $T(n −1)$,<br>                e.g., $T(n) = T(n − 1) + 2T(n − 2)$ is a <strong>second-order</strong> recurrence.<br>    <strong>Linear</strong>: the $T(n − 1)$ only appears to the first power<br>             e.g., $T(n) = (T(n − 1))2 + 3$ is a <strong>non-linear first-order</strong> recurrence.</p><h2 id="Divide-and-Conquer-Recurrences"><a href="#Divide-and-Conquer-Recurrences" class="headerlink" title="Divide-and-Conquer Recurrences"></a>Divide-and-Conquer Recurrences</h2><p><strong>Divide and conquer (D&amp;C)</strong>: recursively breaks down a problem  into two or more sub-problems <strong>of the same or related type</strong>, until  these become simple enough to be solved directly; the solutions  to the sub-problems are then combined to give a solution to the  original problem.</p><p>Divide-and-conquer recurrence relations are usually of the form: <script type="math/tex">T(n)= \begin{cases} \text{something given}& \text{if $n\le n_0$}\\ r\cdot T(\dfrac{n}{m})+g(n)& \text{if $n> n_0$} \end{cases}</script></p><h3 id="Example-Binary-Search"><a href="#Example-Binary-Search" class="headerlink" title="Example: Binary Search"></a>Example: Binary Search</h3><p>Problem: Someone has chosen an integer x between 1 and n. We need to find this secret<br>    We only need to ask two types of questions:<br>        Is x greater than k?<br>        Is x equal to k?<br>Strategy: We first always ask greater than questions, at each step halving our search range, until the range contains only one  number, then we ask a final equal to question.</p><p>D&amp;C: Each guess reduces the size of the problem to only half as  big, then we can (recursively) conquer this smaller problem.<br>When n is a power of 2, the number of comparisons T(n) in a  binary search on {1, 2, …, n} satisfie</p><script type="math/tex; mode=display">T(n)= \begin{cases} 1& \text{$n=1$}\\ T(\dfrac{n}{2})+1& \text{$n\geq2$} \end{cases}</script><p><strong>Proof of correctness</strong> (by strong induction) of the running time:<br>    Basis step ($n = 1$): only one “equal to” comparison is needed<br>    Inductive step ($n ≥ 2$): one “great than” comparison + time to  perform binary search on the remaining $n/2$ term</p><p><strong>Solve by iteration</strong>:<br>$T(n)=T(\dfrac{n}{2})+1=T(\dfrac{n}{2^2})+2=T(\dfrac{n}{2^i})+i$<br>Note that this terminates when $i=log_2n$<br>$T(n)=T(\dfrac{n}{2^{log_2n}})+log_2n=1+log_2n$</p><h3 id="Example-1-T-n-begin-cases-1-text-n-1-2T-dfrac-n-2-n-text-n-geq2-end-cases"><a href="#Example-1-T-n-begin-cases-1-text-n-1-2T-dfrac-n-2-n-text-n-geq2-end-cases" class="headerlink" title="Example 1: T(n)= \begin{cases} 1& \text{$n=1$}\\ 2T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}"></a>Example 1: <script type="math/tex">T(n)= \begin{cases} 1& \text{$n=1$}\\ 2T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 2 subproblems of size $n/2$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n = 1$.<br>    this is exactly how Merge Sort (from an algorithm course) works.</p><p><strong>Solve by iteration</strong>:<br>$T(n)=2T(\dfrac{n}{2})+n=4T(\dfrac{n}{4})+2n=…=2^iT(\dfrac{n}{2^i})+in$<br>Note that this terminates when $i=log_2n$<br>$T(n)=2^{log_2n}T(\dfrac{n}{2^{log_2n}})+n\cdot log_2n=nT(1)+nlog_2n$</p><h3 id="Example-2-T-n-begin-cases-1-text-n-1-T-dfrac-n-2-n-text-n-geq2-end-cases"><a href="#Example-2-T-n-begin-cases-1-text-n-1-T-dfrac-n-2-n-text-n-geq2-end-cases" class="headerlink" title="Example 2: T(n)= \begin{cases} 1& \text{$n=1$}\\ T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}"></a>Example 2: <script type="math/tex">T(n)= \begin{cases} 1& \text{$n=1$}\\ T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 1 subproblem of size $n/2$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n = 1$.</p><p><strong>Solve by iteration</strong>:<br>$T(n)=T(\dfrac{n}{2})+n=T(\dfrac{n}{2^2})+\dfrac{n}{2}+n=T(\dfrac{n}{2^3})+\dfrac{n}{2^2}+\dfrac{n}{2}+n=…=T(\dfrac{n}{2^i})+\dfrac{n}{2^{i-1}}+…+\dfrac{n}{2^2}+\dfrac{n}{2}+n$<br>Note that this teminates when $i=log_2n$<br>$T(n)=T(\dfrac{n}{2^{log_2n}})+\dfrac{n}{2^{log_2n-1}}+…+\dfrac{n}{2^2}+\dfrac{n}{2}+n=1+2+2^2+2^3+…+\dfrac{n}{2^2}+\dfrac{n}{2}+n=2n-1$ <strong>//geometric series’ sum</strong></p><h3 id="Example-3-T-n-begin-cases-1-text-n-1-4T-dfrac-n-2-n-text-n-geq2-end-cases"><a href="#Example-3-T-n-begin-cases-1-text-n-1-4T-dfrac-n-2-n-text-n-geq2-end-cases" class="headerlink" title="Example 3:T(n)= \begin{cases} 1& \text{$n=1$}\\ 4T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}"></a>Example 3:<script type="math/tex">T(n)= \begin{cases} 1& \text{$n=1$}\\ 4T(\dfrac{n}{2})+n& \text{$n\geq2$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 4 subproblem of size $n/2$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n = 1$.</p><p><strong>Solve by iteration</strong>:<br>$T(n)= 4T(\dfrac{n}{2})+n=4^2T(\dfrac{n}{2^2})+\dfrac{4}{2}n+n=4^3T(\dfrac{n}{2^3})+\dfrac{4^2}{2^2}n+\dfrac{4}{2}n+n=…=4^iT(\dfrac{n}{2^i})+\dfrac{4^{i-1}}{2^{i-1}}n+…+\dfrac{4}{2}n+n$<br>Note that this teminates when $i=log_2n$</p><script type="math/tex; mode=display">T(n)=4^{log_2n}T(\dfrac{n}{2^{log_2n}})+\dfrac{4^{log_2n-1}}{2^{log_2n-1}}n+...+\dfrac{4}{2}n+n=n^2+(\dfrac{n^2/4}{n/2}n)+(\dfrac{n^2/4^2}{n/2^2}n)...+2n+n=n^2+\dfrac{1}{2}n^2+\dfrac{1}{2^2}n^2+...+\dfrac{4}{2}n+n</script><p>Part 1 is $4^{log_2n}T(\dfrac{n}{2^{log_2n}})=n^2$</p><p>Part 2 is $\dfrac{4^{log_2n-1}}{2^{log_2n-1}}n+…+\dfrac{4}{2}n+n$, each item can be written as $2^kn$, which is a geometric series of common ratio 2.</p><p>Thus, $\sum^{k-1}_{i=0}2^i=2^k-1=(n-1)$</p><p>So, Part 2 = $(n-1)n$</p><script type="math/tex; mode=display">T(n)= 2n^2-1</script><h3 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h3><p>Compare the iteration for the following recurrences ($T(1) = 1$):<br>    $T(n) = T(n / 2) + n$                 $T(n) = 2n – 1 = Θ(n)$<br>    $T(n) = 2T(n / 2) + n$               $T(n) = n + n log_2 n = Θ(n log n)$<br>    $T(n) = 4T(n / 2) + n $               $T(n) = 2n2 – n = Θ(n2)$<br>All three recurrences iterate $log_2n$ times. The size of subproblem in next iteration is half the size in the preceding iteration level.</p><p><strong>Theorem</strong>: Consider a recurrence relation $T(n) = aT(n / 2) + n$ whenever $n = 2^k$, where $a ≥ 1$ and $T(1) = Θ(1)$.<br>Then we have the  following big Θ bounds on the solution:<br>    If $1 ≤ a &lt; 2$, then $T(n) = Θ(n)$.<br>    If $a = 2$, then $T(n) = Θ(n log n)$.<br>    If $a &gt; 2$, then $T(n) = Θ(n^{log2a}).$ </p><p><strong>Master Theorem</strong>: For a recurrence relation $T(n) = aT(n / b) + cn^d$ whenever $n = b^k$, where $a ≥ 1$, $c &gt; 0$, $d ≥ 0$, integer $b ≥ 2$, and $T(1) = Θ(1)$, we have the following big Θ bounds on the solution:<br>    If $1 ≤ a &lt; b^d$, then $T(n) = Θ(n^d)$.<br>    If $a = b^d$, then $T(n) = Θ(n^d log n)$.<br>    If $a &gt; b^d$, then $T(n) = Θ(n^{log_ba})$.</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="1-Show-that-1-2-···-n-n-n-1-2-for-any-positive-integer-n"><a href="#1-Show-that-1-2-···-n-n-n-1-2-for-any-positive-integer-n" class="headerlink" title="1. Show that $1 + 2 + ··· + n = n(n + 1)/2$ for any positive integer n."></a>1. Show that $1 + 2 + ··· + n = n(n + 1)/2$ for any positive integer n.</h3><p><strong>Proof by mathematical induction:</strong><br>Let P(n) be the predicate that the sum of the first n positive integers is equal to n(n + 1)/2.<br>    <strong>Basis step</strong>: $P(1)$ is true, because $1 = 1(1 + 1)/2$.<br>    <strong>Inductive step</strong>: From the inductive hypothesis, i.e., $P(k)$ is true for an arbitrary positive integer $k$, we need to show that $P(k + 1)$ is true, i.e., $1 + 2 + ··· + k + 1 = (k + 1)((k + 1) + 1)/2$.<br>    $1 + 2 + ··· + k + (k + 1) = k(k + 1)/2 + k + 1 = (k(k + 1) + 2(k + 1))/2 = (k + 1)(k + 2)/2 = (k + 1)((k + 1) + 1)/2$<br>    By mathematical induction, we know that $P(n)$ is true for all positive integers $n$. That is, we have proven that $1 + 2 + ··· + n = n(n + 1)/2$ <strong>holds</strong> for <strong>all</strong> positive integers $n$.</p><h3 id="2-Prove-that-for-any-integer-n-≥-2-2-n-1-≥-n-2-3"><a href="#2-Prove-that-for-any-integer-n-≥-2-2-n-1-≥-n-2-3" class="headerlink" title="2. Prove that for any integer $n ≥ 2, 2^{n+1} ≥ n^2 + 3$ ."></a>2. Prove that for any integer $n ≥ 2, 2^{n+1} ≥ n^2 + 3$ .</h3><p><strong>Proof by mathematical induction:</strong><br>Let $P(n)$ be the predicate that $\forall n ≥ 2, 2^{n+1} ≥ n^2 + 3$<br>    <strong>Basic step</strong>: $P(1)$ is true, because $2^{1+1}=4 \geq 1^2+3=4$<br>    <strong>Inductive step</strong>: From the inductive hypothesis, i.e., $P(k)$ is true for an arbitrary positive integer $k$, we need to show that $P(k + 1)$ is true, i.e., $2^{(k+1)+1} \geq (k+1)^2+3$<br>    $2^{(k+1)+1} \geq 2 \cdot2^{(k+1)} \geq 2(k^2+3) = 2k^2+6=(k+1)^2+(k-1)^2+4\geq (k+1)^2+3$<br>By mathematical induction, $P(n)$ is true for <strong>all</strong> integers $n ≥ 2$.</p><h3 id="3-Prove-Every-positive-integer-is-a-power-of-a-prime-or-the-product-of-powers-of-primes"><a href="#3-Prove-Every-positive-integer-is-a-power-of-a-prime-or-the-product-of-powers-of-primes" class="headerlink" title="3. Prove: Every positive integer is a power of a prime or the product of powers of primes."></a>3. Prove: Every positive integer is a power of a prime or the product of powers of primes.</h3><p>Proof by strong induction: $P(n)$: “$n$ is a power of a prime or the product of powers of primes”<br>    <strong>Basis step</strong>: $P(1)$ is true, as 1 is a power of a prime number, $1 = 2^0$<br>    <strong>Inductive step</strong>: Inductive hypothesis: $P(m)$ is true for every $m$ that $1 ≤ m ≤ k$, i.e., $m$ is a power of a prime or a product of powers of primes.<br>    If $k + 1$ is a prime power, $P(k + 1)$ is true.<br>    Otherwise, $k + 1$ must be a composite, i.e., a product of two smaller positive integers, each of which is, by the inductive hypothesis, a power of a prime or the product of powers of primes. Therefore, $P(k + 1)$ is true.<br>    Finally, by strong induction, $P(n)$ is true for all positive integers.</p><h3 id="4-Solve-T-n-rT-n-−-1-g-n-with-T-0-a-and-constant-r-≠-0"><a href="#4-Solve-T-n-rT-n-−-1-g-n-with-T-0-a-and-constant-r-≠-0" class="headerlink" title="4. Solve $T(n) = rT(n − 1) + g(n)$ with $T(0) = a$ and constant $r ≠ 0$."></a>4. Solve $T(n) = rT(n − 1) + g(n)$ with $T(0) = a$ and constant $r ≠ 0$.</h3><p>Hint: write $T(n)$ in terms of $r, n$, $T(0)$ and $g(i)$</p><p>$T(n) = rT(n − 1) + g(n)=r(rT(n − 2) + g(n-1))+g(n)=r^2T(n-2)+rg(n-1)+g(n)=…$</p><p>We have $T(n)=r^nT(0)+\sum^{n-1}_{i=0}r^{i}g(n-i)$</p><h3 id="5-Solve-T-n-4T-n-−-1-2-n-n-gt-0-with-T-0-6"><a href="#5-Solve-T-n-4T-n-−-1-2-n-n-gt-0-with-T-0-6" class="headerlink" title="5. Solve $T(n) = 4T(n − 1) + 2^n (n &gt; 0)$ with $T(0) = 6$"></a>5. Solve $T(n) = 4T(n − 1) + 2^n (n &gt; 0)$ with $T(0) = 6$</h3><p>Hint: write $T(n)$ in terms of $4^n$ and $2^n$</p><script type="math/tex; mode=display">T(n)=4^n\cdot6+\sum^{n}_{i=1}4^{n-i}2^i=4^n\cdot6+4^n\sum^n_{i=1}4^{-i}\cdot2^i=4^n\cdot6+4^n\sum^n_{i=1}(\frac{1}{2})^i=4^n\cdot6+4^n\cdot(1-\dfrac{1}{2^n})=7\cdot4^n-2^n</script><h3 id="6-Solve-this-recurrence-by-iteration-T-n-begin-cases-1-text-n"><a href="#6-Solve-this-recurrence-by-iteration-T-n-begin-cases-1-text-n" class="headerlink" title="6.Solve this recurrence by iteration T(n)= \begin{cases} 1& \text{$n"></a>6.Solve this recurrence by iteration <script type="math/tex">T(n)= \begin{cases} 1& \text{$n<3$}\\ 3T(\dfrac{n}{3})+n& \text{$n\geq3$} \end{cases}</script></h3><p>This corresponds to solving a problem of size n, by either<br>    (i) solving 3 subproblem of size $n/3$;<br>    (ii) doing $n$ units of additional work  or using $T(1)$ work for the case of $n &lt;3$.</p><p>$T(n)=3T(\dfrac{n}{3})+n=3^2T(\dfrac{n}{3^2})+2n=…=3^iT(\dfrac{n}{3^i})+in$<br>Note that this teminates when $i=log_3n$<br>$T(n)=3^{log_3n}T(\dfrac{n}{3^{log_3n}})+nlog_3n=nT(1)+nlog_3n=n+nlog_3n$</p>]]></content>
      
      
      <categories>
          
          <category> Discrete Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discrete Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic</title>
      <link href="/2024/11/23/Digital%20Logic%20Chapter%205%20part%202:Synchronous%20Sequential%20Logic/"/>
      <url>/2024/11/23/Digital%20Logic%20Chapter%205%20part%202:Synchronous%20Sequential%20Logic/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-2-Synchronous-Sequential-Logic"><a href="#Digital-Logic-Chapter-5-part-2-Synchronous-Sequential-Logic" class="headerlink" title="Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic"></a>Digital Logic Chapter 5 part 2 - Synchronous Sequential Logic</h1><h2 id="Analysis-of-Sequential-Circuits"><a href="#Analysis-of-Sequential-Circuits" class="headerlink" title="Analysis of Sequential Circuits"></a>Analysis of Sequential Circuits</h2><h3 id="Ways-to-describe-a-digital-circuit"><a href="#Ways-to-describe-a-digital-circuit" class="headerlink" title="Ways to describe a digital circuit"></a>Ways to describe a digital circuit</h3><p>logic diagram (逻辑电路图): graphical representation of a digital circuit that uses standard symbols</p><p>K-map (卡诺图): graphical representation of a logic function used to simplify Boolean expressions</p><p>function table (功能表)(truth table): list of all possible input combinations and the corresponding output values for a given logic function</p><p>characteristic equations (特征方程): Describe the behavior of a sequential logic circuit, the next state is defined as a function of the inputs and the present state</p><p>excitation/input equation (激励方程): Defines the part of the circuit that generates the inputs to sequential logic circuit</p><p>state table (状态表): tabular representation of a sequential logic circuit that shows the current state, input, next state, and output for all possible input combinations</p><p>state equation (次态方程): defines the next state of a sequential logic circuit based on the current state and input values</p><p>state diagram (状态图): graphical representation of a sequential logic circuit that shows the states, transitions, and input-output relationships</p><h3 id="Analysis-Procedure-of-Clocked-Sequential-Circuits"><a href="#Analysis-Procedure-of-Clocked-Sequential-Circuits" class="headerlink" title="Analysis Procedure of Clocked Sequential Circuits"></a>Analysis Procedure of Clocked Sequential Circuits</h3><h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h4><ol><li>Derive excitation/input equations for FF inputs</li><li>Derive state and output equations<br> Substitute the excitation equations into the flip-flop characteristic equations to obtain next state equations.<br> Determine the output equations according current state and input </li><li>Generate state and output tables</li><li>Generate state diagram</li></ol><p>Important: FF’s Characteristic equation:<br>DFF   $Q(t+1) = D(t)$<br>JKFF $Q(t+1) = J(t)Q(t)’ + K(t)’Q(t)$<br>TFF   $Q(t+1) = T(t)’Q(t) + T(t)Q(t)’$</p><h4 id="Example-1-using-DFF-Q-t-1-D-t"><a href="#Example-1-using-DFF-Q-t-1-D-t" class="headerlink" title="Example 1 using DFF $Q(t+1) = D(t)$:"></a>Example 1 using DFF $Q(t+1) = D(t)$:</h4><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2021.56.jpeg" alt="图像2024-11-23 21.56" style="zoom:33%;" /></p><ol><li>Derive excitation/input equations for FF inputs<br> $D_A = Q_Ax + Q_Bx$<br> $D_B = Q_A’x$</li><li>State equation<br> $Q_A(t+1) = D_A(t)=Q_Ax + Q_Bx$<br> $Q_B(t+1) = D_B(t) = Q_A’(t)x(t)$</li><li>Output equation<br> $y(t) = (Q_A(t) + Q_B(t))x’(t)$<br> All signals are labeled by t, thus $y = (Q_A + Q_B)x’$</li><li>Generate state and output tables</li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>Output</th></tr></thead><tbody><tr><td>$Q_A$</td><td>$Q_B$</td><td>$x$</td><td>$Q_{Anext}$</td><td>$Q_{Bnext}$</td><td>$y$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><ol><li><p>Generate state diagram</p><p> <img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2022.45.jpeg" alt="图像2024-11-23 22.45" style="zoom:33%;" /></p></li></ol><h4 id="Example-2-using-JKFF-Q-t-1-J-t-Q-t-’-K-t-’Q-t"><a href="#Example-2-using-JKFF-Q-t-1-J-t-Q-t-’-K-t-’Q-t" class="headerlink" title="Example 2 using JKFF $Q(t+1) = J(t)Q(t)’ + K(t)’Q(t)$:"></a>Example 2 using JKFF $Q(t+1) = J(t)Q(t)’ + K(t)’Q(t)$:</h4><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2022.48.jpeg" alt="图像2024-11-23 22.48" style="zoom:33%;" /></p><ol><li><p>Derive excitation/input equations for FF inputs<br>$J_A = B$<br>$K_A= Bx’$<br>$J_B=x’$<br>$K_B=A \oplus x$</p></li><li><p>State equation<br>$A(t+1) = J_AA’ + K_A’A= BA’ + (Bx’)’A$<br>$B(t+1) = J_BB’ + K’_BB=B’x’ +(A \oplus x)’B $</p></li><li><p>No extra output equations</p></li><li><p>Generate state and output tables</p></li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>FF inputs</th><th>FF inputs</th><th>FF inputs</th><th>FF inputs</th></tr></thead><tbody><tr><td>$A$</td><td>$B$</td><td>$x$</td><td>$A_{next}$</td><td>$B_{next}$</td><td>$J_A$</td><td>$K_A$</td><td>$J_B$</td><td>$K_B$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><ol><li>Generate state diagram<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.10.jpeg" alt="图像2024-11-23 23.10" style="zoom:33%;" /></li></ol><h4 id="Example-3-using-TFF-Q-t-1-T-t-’Q-t-T-t-Q-t-’"><a href="#Example-3-using-TFF-Q-t-1-T-t-’Q-t-T-t-Q-t-’" class="headerlink" title="Example 3 using TFF $Q(t+1) = T(t)’Q(t) + T(t)Q(t)’$:"></a>Example 3 using TFF $Q(t+1) = T(t)’Q(t) + T(t)Q(t)’$:</h4><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.16.jpeg" alt="图像2024-11-23 23.16" style="zoom:40%;" /></p><ol><li><p>Derive excitation/input equations for FF inputs<br>$T_A = Bx$<br>$T_B = x$</p></li><li><p>State equation<br>$A(t+1) = T_A \oplus Q_A = (Bx) \oplus A$<br>$B(t+1)=T_B \oplus Q_B = x \oplus B$</p></li><li><p>Output equation<br>$y = AB$</p></li><li><p>Generate state and output tables</p></li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Present state</th><th>Input</th><th>Next state</th><th>Next state</th><th>Output</th></tr></thead><tbody><tr><td>$A$</td><td>$B$</td><td>$x$</td><td>$A_{next}$</td><td>$B_{next}$</td><td>$y$</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><ol><li>Generate state diagram<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.29.jpeg" alt="图像2024-11-23 23.29" style="zoom:33%;" /></li></ol><h2 id="Finite-State-Machine"><a href="#Finite-State-Machine" class="headerlink" title="Finite State Machine"></a>Finite State Machine</h2><p>A synchronous sequential circuit can be modeled by FSM.</p><p>State register $𝑞(t+1) = 𝑞_{next}(t)$<br>    Stores current state<br>    Loads next state at clock edge</p><p>Combinational logic<br>    Computes next state (next state logic $h: x × 𝑞 → 𝑞_{𝑛𝑒𝑥𝑡}$ )<br>    Computes outputs<br>        output logic $f: x × 𝑞 → 𝑦$ (Mealy machine, with blue line)<br>                or $f: 𝑞 → 𝑦$ (Moore machine, without blue line)</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.47.jpeg" alt="图像2024-11-23 23.47" style="zoom:33%;" /></p><p>Two types of finite state machines differ in output logic:<br>    Moore FSM: outputs depend only on current state<br>    Mealy FSM: outputs depend on current state and inputs, to synchronize a Mealy circuit, the inputs must be synchronized with the clock and the outputs must be sampled immediately before the clock edge</p><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-23%2023.56.jpeg" alt="图像2024-11-23 23.56" style="zoom:33%;" /></p><h2 id="State-Minimization-amp-Encoding"><a href="#State-Minimization-amp-Encoding" class="headerlink" title="State Minimization &amp; Encoding"></a>State Minimization &amp; Encoding</h2><h3 id="State-minimization"><a href="#State-minimization" class="headerlink" title="State minimization"></a>State minimization</h3><p>Reductions on the number of flip-flops (states) and the number of gates.<br>For an FSM with m states, we need $log_2m$ FFs.</p><p>Reduction steps</p><ol><li>Find rows in the state table that have identical next state and output entries. They correspond to equivalent states. If there are no equivalent states, stop.</li><li>When 2 states are equivalent, one of them can be removed. Update the entries of the remaining table to cancel the removed state. Go to 1.</li></ol><p>Example:<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2000.27.jpeg" alt="图像2024-11-24 00.27" style="zoom:50%;" /> $\longrightarrow$<img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2000.29.jpeg" alt="图像2024-11-24 00.29" style="zoom:50%;" /></p><p><strong>Start table:</strong></p><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td>d</td><td>e</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>e</u></td><td><u>a</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr><tr><td>f</td><td>g</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>g</u></td><td><u>a</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr></tbody></table></div><p><strong>1st turn:</strong> $e \equiv g$</p><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td><u>d</u></td><td><u>e</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr><tr><td>e</td><td>a</td><td>f</td><td>0</td><td>1</td></tr><tr><td><u>f</u></td><td><del>g</del>   <u>e</u></td><td><u>f</u></td><td><u>0</u></td><td><u>1</u></td></tr></tbody></table></div><p><strong>2nd turn:</strong> $d \equiv f$</p><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td></td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>a</td><td>a</td><td>b</td><td>0</td><td>0</td></tr><tr><td>b</td><td>c</td><td>d</td><td>0</td><td>0</td></tr><tr><td>c</td><td>a</td><td>d</td><td>0</td><td>0</td></tr><tr><td>d</td><td>e</td><td><del>f</del>   d</td><td>0</td><td>1</td></tr><tr><td>e</td><td>a</td><td><del>f</del>   d</td><td>0</td><td>1</td></tr></tbody></table></div><h3 id="Encoding-assign-binary-state-to-the-states"><a href="#Encoding-assign-binary-state-to-the-states" class="headerlink" title="Encoding(assign binary state to the states)"></a>Encoding(assign binary state to the states)</h3><p>Different state encodings (assignments) result in different circuits for the intended FSM.<br>There is no easy state-encoding procedure that guarantees a minimal-cost or minimum-delay combinational circuits<br>    Exploration of all possibilities are impossible.<br>    Heuristic are often used.<br>        Binary counting<br>        Minimum-bit change<br>        One-hot encoding</p><h2 id="Design-of-Sequential-Circuits"><a href="#Design-of-Sequential-Circuits" class="headerlink" title="Design of Sequential Circuits"></a>Design of Sequential Circuits</h2><h3 id="Design-Procedure-of-Sequential-Circuits"><a href="#Design-Procedure-of-Sequential-Circuits" class="headerlink" title="Design Procedure of Sequential Circuits"></a>Design Procedure of Sequential Circuits</h3><ol><li>Specification: design description or timing diagram</li><li>Formulation: develop state diagram</li><li>Generate state and output tables</li><li>Minimize States if necessary</li><li>Assign binary values to the state (encoding)</li><li>Derive state and output equations</li><li><strong>Choose memory elements (DFFs, JKFFs, TFFs)</strong></li><li>Derive simplified excitation/input equations and output equations</li><li>Draw logic schematic</li></ol><h3 id="Choice-of-Memory-Elements"><a href="#Choice-of-Memory-Elements" class="headerlink" title="Choice of Memory Elements"></a>Choice of Memory Elements</h3><p>Given the state transition table, we wish to find the FF input conditions that will cause the required transition.<br>    A tool for such a purpose is the excitation table, which can be derived from the characteristic table/equation.<br>    D FFs are good for applications requiring data transfer (shift registers).<br>    T FFs are good for those involving complementation (binary counters).<br>    Many digital systems are constructed entirely with JK FFs because they are the most versatile available.</p><h3 id="FF’s-Excitation-Table"><a href="#FF’s-Excitation-Table" class="headerlink" title="FF’s Excitation Table"></a>FF’s Excitation Table</h3><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.51.jpeg" alt="图像2024-11-24 01.51" style="zoom:33%;" /></p><h3 id="Design-Example-Design-with-DFF-A-Sequence-Detector"><a href="#Design-Example-Design-with-DFF-A-Sequence-Detector" class="headerlink" title="Design Example: Design with DFF: A Sequence Detector"></a>Design Example: Design with DFF: A Sequence Detector</h3><ol><li><p>Detect three consecutive 1’s in a string of bits (using Moore machine, overlapping)<br>If detected, output=1; otherwise output=0</p></li><li><p>State diagram<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.15.jpeg" alt="图像2024-11-24 01.15" style="zoom:33%;" /></p></li><li><p>State and output table</p></li></ol><div class="table-container"><table><thead><tr><th>Present state</th><th>Next state</th><th>Next state</th><th>Output</th><th>Output</th></tr></thead><tbody><tr><td>$S(AB)$</td><td>$x=0$</td><td>$x=1$</td><td>$x=0$</td><td>$x=1$</td></tr><tr><td>$S_0 (00)$</td><td>$S_0$</td><td>$S_1$</td><td>0</td><td>0</td></tr><tr><td>$S_1(01)$</td><td>$S_0$</td><td>$S_2$</td><td>0</td><td>0</td></tr><tr><td>$S_2(10)$</td><td>$S_0$</td><td>$S_3$</td><td>0</td><td>0</td></tr><tr><td>$S_3(11)$</td><td>$S_0$</td><td>$S_3$</td><td>1</td><td>1</td></tr></tbody></table></div><ol><li><p>No need for simplification</p></li><li><p>State assignment in 3</p></li><li><p>Derive state and output equations</p></li></ol><div class="table-container"><table><thead><tr><th>$A(t)$</th><th>$B(t)$</th><th>$x$</th><th>$A(t+1)$</th><th>$B(t+1)$</th><th>$y$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>  $A(t+1)=D_A(A(t),B(t),x)=\Sigma(3,5,7)$<br>  $B(t+1)=D_B(A(t),B(t),x)=\Sigma(1,5,7)$<br>  $y(A,B,x)=\Sigma(6,7)$</p><ol><li><p>Choose DFFs<br>2 bits encoding leads to 2 DFFs.<br>$A(t+1) =D_A(t)$<br>$B(t+1)=D_B(t)$</p></li><li><p>Derive simplified excitation/input equations and output equations<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-24%2001.47.jpeg" alt="图像2024-11-24 01.47" style="zoom:40%;" /><br>$D_A=Ax+Bx$<br>$D_B=Ax+B’x$<br>$y=AB$</p></li><li><p>Logic schematic(Omitted)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital Logic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</title>
      <link href="/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/"/>
      <url>/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops"><a href="#Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops" class="headerlink" title="Digital Logic Chapter 5 part 1 - Latches and Flip-flops"></a>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</h1><h2 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h2><p>A sequential circuit consists of a combinational circuit to which storage elements are connected to form a feedback path.<br>The binary information stored in the memory elements at any given time defines the state of the sequential circuits.<br>$(inputs, current State)$ $\Longrightarrow$ $(outputs, next State)$, the behavior is specified by a time sequence of inputs and internal states.</p><h3 id="Synchronous-Sequential-Circuits"><a href="#Synchronous-Sequential-Circuits" class="headerlink" title="Synchronous Sequential Circuits"></a>Synchronous Sequential Circuits</h3><p>A system whose behavior can be defined from the knowledge of its signals at <strong>discrete</strong> instants of time.<br>Usually achieved by a timing device: clock generator, which means the outputs are affected only with the application of a clock pulse.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.04.jpeg" alt=""></p><h3 id="Asynchronous-Sequential-Circuits"><a href="#Asynchronous-Sequential-Circuits" class="headerlink" title="Asynchronous Sequential Circuits"></a>Asynchronous Sequential Circuits</h3><p>A system whose behavior depends upon input signals at <strong>any</strong> instant of time and the order in which the inputs change.<br>Commonly used storage devices are time-delay devices, and the propagation delay of the logic gates (time-delay devices) provides the required storage.<br>Can be viewed as combinational circuit with feedback, and can be unstable at times</p><h2 id="Storage-Elements"><a href="#Storage-Elements" class="headerlink" title="Storage Elements"></a>Storage Elements</h2><p>State: all the information about a circuit necessary to explain its future behavior </p><h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><h4 id="SR-Latch"><a href="#SR-Latch" class="headerlink" title="SR Latch"></a>SR Latch</h4><h5 id="SR-Latch-1"><a href="#SR-Latch-1" class="headerlink" title="SR Latch"></a>SR Latch</h5><p>It stores 1 bit of infomation, consists of two cross-coupled NOR gates or NAND gates.<br>Two input signals: $set(S)/Reset(R)$<br>Two output signals: $Q/Q’$<br>Two useful states: $setState(Q=1,Q’=0)/resetState(Q=0,Q’=1)$<br>Note: $Q$ and $Q’$ should always be different. And $(S,R)$ should go back to $(0,0)$ before any other changes to avoid the occurrence of the undefined state.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.23.jpeg" style="zoom:28%;" /></p><p>Consider 4 possible cases:<br>1.$S=1,R=0$ $\Longrightarrow$ $Q=1,Q’=0$ <strong>Set the output</strong>.<br>2.$S=0,R=1$ $\Longrightarrow$ $Q=0,Q’=1$ <strong>Reset the output</strong>.<br>3.$S=0,R=0$ $\Longrightarrow$ $Q=Q<em>{prev},Q’=Q’</em>{prev}$ <strong>Memory function</strong>.<br>4.$S=1,R=1$ $\Longrightarrow$ $Q=0,Q’=0$ <strong>Forbidden invalid state</strong>.</p><div class="table-container"><table><thead><tr><th style="text-align:left">$S$</th><th style="text-align:left">$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table></div><h5 id="S’R’-Latch-with-NAND-gates"><a href="#S’R’-Latch-with-NAND-gates" class="headerlink" title="S’R’ Latch with NAND gates"></a>S’R’ Latch with NAND gates</h5><p><strong>Low active</strong> Set/Reset inputs<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.36.jpeg" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>Forbidden</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr></tbody></table></div><h5 id="Clocked-SR-Latch"><a href="#Clocked-SR-Latch" class="headerlink" title="Clocked SR Latch"></a>Clocked SR Latch</h5><p>Use Clock (or En) to enable/disable the SR latch<br>$C=0$, no change(disabled)<br>$C=1$, operates as normal SR latch (enabled)<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.42.jpeg" style="zoom:30%;" /></p><div class="table-container"><table><thead><tr><th>$C$</th><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>0</td><td>0</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table></div><h4 id="D-Latch"><a href="#D-Latch" class="headerlink" title="D Latch"></a>D Latch</h4><p>It stores 1 bit of infomation, constructed from a gated SR latch by connecting the D input to S input and D’ to R, which makes sure S and R are different in the SR Latch.<br>Two input signals: $Clock(clk/En)/Data(D)$<br>Two output signals: $Q/Q’$<br>Note: avoid invalid cases in SR Latches.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48.jpeg" alt="图像2024-11-22 10.48" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48%20(1).jpeg" alt="图像2024-11-22 10.48 (1)" style="zoom:38%;" /></p><div class="table-container"><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change(Memory)</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table></div><h3 id="Flip-flop"><a href="#Flip-flop" class="headerlink" title="Flip-flop"></a>Flip-flop</h3><h4 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h4><h5 id="Level-sensitive"><a href="#Level-sensitive" class="headerlink" title="Level sensitive"></a>Level sensitive</h5><p>The state transition starts as soon as the clock is during logic 1 (positive level-sensitive) or logic 0 (negative level-sensitive) level.</p><h5 id="Edge-triggered"><a href="#Edge-triggered" class="headerlink" title="Edge triggered"></a>Edge triggered</h5><p>The state transition starts only at positive (positive edge-triggered) or negative edge (negative edge-triggered) of the clock signal.</p><h4 id="D-Flip-flop"><a href="#D-Flip-flop" class="headerlink" title="D Flip-flop"></a>D Flip-flop</h4><h5 id="Standard-DFF-Properties"><a href="#Standard-DFF-Properties" class="headerlink" title="Standard DFF Properties"></a>Standard DFF Properties</h5><p>Inputs: $Clk$,$D$<br>A D flip-flop is formed by two separate latches:<br>A master D latch (negative level sensitive)<br>A slave D latch (positive level sensitive)<br>Positive-edge-triggered D flip-flop:<br>When $CLK = 0$:<br>    master is transparent<br>    slave is opaque<br>    D passes through to P<br>When $CLK = 1$<br>    master is opaque<br>    slave is transparent<br>    P passes through to Q<br>Thus, on the rising edge of the clock ($CLK$ rises from 0$\rightarrow$1)<br>    D passes through to Q<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2013.27.jpeg" alt="图像2024-11-22 13.27" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>↑</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table></div><h5 id="Setup-time-and-hold-time"><a href="#Setup-time-and-hold-time" class="headerlink" title="Setup time and hold time"></a>Setup time and hold time</h5><p><strong>Setup time</strong><br>    D input must be maintained at a constant value prior to the application of the positive Clk pulse<br><strong>Hold time</strong><br>    Data input must not change after the application of the positive Clk pulse</p><h5 id="DFF-with-Reset"><a href="#DFF-with-Reset" class="headerlink" title="DFF with Reset"></a>DFF with Reset</h5><p>Active low reset<br>$Reset = 0$: Q is forced to 0<br>$Reset = 1$: flip-flop behaves as ordinary D flip-flop</p><div class="table-container"><table><thead><tr><th>$R$</th><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>0</td><td>1</td><td>Reset on power, forced $Q = 0$</td></tr><tr><td>1</td><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>$\uparrow$</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2014.06.jpeg" alt="图像2024-11-22 14.06" style="zoom:40%;" /></p><p>The state of FFs are unknown when power is on. A direct input can force the FFs to a known state before the system starts.<br>    E.g. when $Reset = 1$, FF’s output is forced to 0<br>Synchronous vs. asynchronous resettable Flip Flop<br>    Asynchronous: resets immediately when $Reset = 1$<br>    Synchronous: resets at the clock edge only</p><h4 id="J-K-Flip-flop"><a href="#J-K-Flip-flop" class="headerlink" title="J-K Flip-flop"></a>J-K Flip-flop</h4><p>e.g. <strong>Positive edge-triggered JKFF</strong></p><p>At rising edge of clock<br>$J = K = 0$, Q is unchanged<br>$J = K = 1$, Q toggles<br>$J = 1, K = 0$, Q is set to 1<br>$J = 0, K = 1$, Q is reset to 0<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="图像2024-11-22 16.01" style="zoom:33%;" /></p><p><strong>Characteristic equation:</strong></p><script type="math/tex; mode=display">Q(t+1)= J’K’Q(t) + J’K•0 + JK’•1 + JKQ(t)’= J’K’Q(t) + JK’ + JKQ(t)’= J’K’Q(t) + JK’Q(t) + JK’Q(t)’ + JKQ(t)’= JQ(t)’ + K’Q(t)</script><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.21.jpeg" alt="图像2024-11-22 16.21" style="zoom:33%;" /></p><h4 id="T-Flip-flop"><a href="#T-Flip-flop" class="headerlink" title="T Flip-flop"></a>T Flip-flop</h4><p>T: Toggle<br>$T = 0$, a clock edge does not change the output.<br>$T = 1$, a clock edge complements the output.<br>Useful for designing binary counters.</p><div class="table-container"><table><thead><tr><th>$T$</th><th>$Q_{next}$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>$Q$</td><td>no change</td></tr><tr><td>1</td><td>$Q’$</td><td>take $Q$’s complement</td></tr></tbody></table></div><p><strong>Characteristic equation:</strong></p><script type="math/tex; mode=display">Q(t+1) = T’Q(t) + TQ(t)’= T⊕Q(t)</script><p><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2021.03.jpeg" alt="图像2024-11-22 21.03" style="zoom:33%;" /></p><h3 id="Characteristic-Table"><a href="#Characteristic-Table" class="headerlink" title="Characteristic Table"></a>Characteristic Table</h3><p><strong>Characteristic table</strong>: describe the behavior of a flip-flop based on its input and current state Q(t) just before the rising edge of the clock, and the resulting next state Q(t+1) after the clock transition.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="图像2024-11-22 16.01" style="zoom:40%;" /></p><p><strong>Characteristic equation</strong>: derived from the Characteristic table, e.g. $Q_{t+1} = D$</p><ol><li>From characteristic table to truth table</li><li>Algebrically or using K-map to get characteristic equation</li></ol>]]></content>
      
      
      <categories>
          
          <category> Digital Logic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FirstPost</title>
      <link href="/2024/11/21/FirstPost/"/>
      <url>/2024/11/21/FirstPost/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
