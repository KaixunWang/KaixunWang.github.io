<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</title>
      <link href="/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/"/>
      <url>/2024/11/22/Digital%20Logic%20Chapter%205%20part1:Latches%20and%20Flip-flops/</url>
      
        <content type="html"><![CDATA[<h1 id="Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops"><a href="#Digital-Logic-Chapter-5-part-1-Latches-and-Flip-flops" class="headerlink" title="Digital Logic Chapter 5 part 1 - Latches and Flip-flops"></a>Digital Logic Chapter 5 part 1 - Latches and Flip-flops</h1><h2 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h2><p>A sequential circuit consists of a combinational circuit to which storage elements are connected to form a feedback path.<br>The binary information stored in the memory elements at any given time defines the state of the sequential circuits.<br>$(inputs, current State)$ $\Longrightarrow$ $(outputs, next State)$, the behavior is specified by a time sequence of inputs and internal states.</p><h3 id="Synchronous-Sequential-Circuits"><a href="#Synchronous-Sequential-Circuits" class="headerlink" title="Synchronous Sequential Circuits"></a>Synchronous Sequential Circuits</h3><p>A system whose behavior can be defined from the knowledge of its signals at <strong>discrete</strong> instants of time.<br>Usually achieved by a timing device: clock generator, which means the outputs are affected only with the application of a clock pulse.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.04.jpeg"></p><h3 id="Asynchronous-Sequential-Circuits"><a href="#Asynchronous-Sequential-Circuits" class="headerlink" title="Asynchronous Sequential Circuits"></a>Asynchronous Sequential Circuits</h3><p>A system whose behavior depends upon input signals at <strong>any</strong> instant of time and the order in which the inputs change.<br>Commonly used storage devices are time-delay devices, and the propagation delay of the logic gates (time-delay devices) provides the required storage.<br>Can be viewed as combinational circuit with feedback, and can be unstable at times</p><h2 id="Storage-Elements"><a href="#Storage-Elements" class="headerlink" title="Storage Elements"></a>Storage Elements</h2><p>State: all the information about a circuit necessary to explain its future behavior </p><h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><h4 id="SR-Latch"><a href="#SR-Latch" class="headerlink" title="SR Latch"></a>SR Latch</h4><h5 id="SR-Latch-1"><a href="#SR-Latch-1" class="headerlink" title="SR Latch"></a>SR Latch</h5><p>It stores 1 bit of infomation, consists of two cross-coupled NOR gates or NAND gates.<br>Two input signals: $set(S)&#x2F;Reset(R)$<br>Two output signals: $Q&#x2F;Q’$<br>Two useful states: $setState(Q&#x3D;1,Q’&#x3D;0)&#x2F;resetState(Q&#x3D;0,Q’&#x3D;1)$<br>Note: $Q$ and $Q’$ should always be different. And $(S,R)$ should go back to $(0,0)$ before any other changes to avoid the occurrence of the undefined state.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.23.jpeg" style="zoom:28%;" /></p><p>Consider 4 possible cases:<br>1.$S&#x3D;1,R&#x3D;0$ $\Longrightarrow$ $Q&#x3D;1,Q’&#x3D;0$ <strong>Set the output</strong>.<br>2.$S&#x3D;0,R&#x3D;1$ $\Longrightarrow$ $Q&#x3D;0,Q’&#x3D;1$ <strong>Reset the output</strong>.<br>3.$S&#x3D;0,R&#x3D;0$ $\Longrightarrow$ $Q&#x3D;Q_{prev},Q’&#x3D;Q’_{prev}$ <strong>Memory function</strong>.<br>4.$S&#x3D;1,R&#x3D;1$ $\Longrightarrow$ $Q&#x3D;0,Q’&#x3D;0$ <strong>Forbidden invalid state</strong>.</p><table><thead><tr><th align="left">$S$</th><th align="left">$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr><tr><td align="left">0</td><td align="left">1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td align="left">1</td><td align="left">0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td align="left">1</td><td align="left">1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table><h5 id="S’R’-Latch-with-NAND-gates"><a href="#S’R’-Latch-with-NAND-gates" class="headerlink" title="S’R’ Latch with NAND gates"></a>S’R’ Latch with NAND gates</h5><p><strong>Low active</strong> Set&#x2F;Reset inputs<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.36.jpeg" style="zoom:25%;" /></p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>Forbidden</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr></tbody></table><h5 id="Clocked-SR-Latch"><a href="#Clocked-SR-Latch" class="headerlink" title="Clocked SR Latch"></a>Clocked SR Latch</h5><p>Use Clock (or En) to enable&#x2F;disable the SR latch<br>$C&#x3D;0$, no change(disabled)<br>$C&#x3D;1$, operates as normal SR latch (enabled)<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.42.jpeg" style="zoom:30%;" /></p><table><thead><tr><th>$C$</th><th>$S$</th><th>$R$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>0</td><td>0</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>Memory</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>Reset</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>Forbidden</td></tr></tbody></table><h4 id="D-Latch"><a href="#D-Latch" class="headerlink" title="D Latch"></a>D Latch</h4><p>It stores 1 bit of infomation, constructed from a gated SR latch by connecting the D input to S input and D’ to R, which makes sure S and R are different in the SR Latch.<br>Two input signals: $Clock(clk&#x2F;En)&#x2F;Data(D)$<br>Two output signals: $Q&#x2F;Q’$<br>Note: avoid invalid cases in SR Latches.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48.jpeg" alt="图像2024-11-22 10.48" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2010.48%20(1).jpeg" alt="图像2024-11-22 10.48 (1)" style="zoom:38%;" /></p><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change(Memory)</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table><h3 id="Flip-flop"><a href="#Flip-flop" class="headerlink" title="Flip-flop"></a>Flip-flop</h3><h4 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h4><h5 id="Level-sensitive"><a href="#Level-sensitive" class="headerlink" title="Level sensitive"></a>Level sensitive</h5><p>The state transition starts as soon as the clock is during logic 1 (positive level-sensitive) or logic 0 (negative level-sensitive) level.</p><h5 id="Edge-triggered"><a href="#Edge-triggered" class="headerlink" title="Edge triggered"></a>Edge triggered</h5><p>The state transition starts only at positive (positive edge-triggered) or negative edge (negative edge-triggered) of the clock signal.</p><h4 id="D-Flip-flop"><a href="#D-Flip-flop" class="headerlink" title="D Flip-flop"></a>D Flip-flop</h4><h5 id="Standard-DFF-Properties"><a href="#Standard-DFF-Properties" class="headerlink" title="Standard DFF Properties"></a>Standard DFF Properties</h5><p>Inputs: $Clk$,$D$<br>A D flip-flop is formed by two separate latches:<br>A master D latch (negative level sensitive)<br>A slave D latch (positive level sensitive)<br>Positive-edge-triggered D flip-flop:<br>When $CLK &#x3D; 0$:<br>    master is transparent<br>    slave is opaque<br>    D passes through to P<br>When $CLK &#x3D; 1$<br>    master is opaque<br>    slave is transparent<br>    P passes through to Q<br>Thus, on the rising edge of the clock ($CLK$ rises from 0$\rightarrow$1)<br>    D passes through to Q<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2013.27.jpeg" alt="图像2024-11-22 13.27" style="zoom:25%;" /></p><table><thead><tr><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>1</td><td>X</td><td>$Q_{prev}$</td><td>$Q’_{prev}$</td><td>no change</td></tr><tr><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>↑</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table><h5 id="Setup-time-and-hold-time"><a href="#Setup-time-and-hold-time" class="headerlink" title="Setup time and hold time"></a>Setup time and hold time</h5><p><strong>Setup time</strong><br>    D input must be maintained at a constant value prior to the application of the positive Clk pulse<br><strong>Hold time</strong><br>    Data input must not change after the application of the positive Clk pulse</p><h5 id="DFF-with-Reset"><a href="#DFF-with-Reset" class="headerlink" title="DFF with Reset"></a>DFF with Reset</h5><p>Active low reset<br>$Reset &#x3D; 0$: Q is forced to 0<br>$Reset &#x3D; 1$: flip-flop behaves as ordinary D flip-flop</p><table><thead><tr><th>$R$</th><th>$C$</th><th>$D$</th><th>$Q$</th><th>$Q’$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>0</td><td>1</td><td>Reset on power, forced $Q &#x3D; 0$</td></tr><tr><td>1</td><td>$\uparrow$</td><td>0</td><td>0</td><td>1</td><td>Q follows D</td></tr><tr><td>1</td><td>$\uparrow$</td><td>1</td><td>1</td><td>0</td><td>Q follows D</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2014.06.jpeg" alt="图像2024-11-22 14.06" style="zoom:40%;" /><p>The state of FFs are unknown when power is on. A direct input can force the FFs to a known state before the system starts.<br>    E.g. when $Reset &#x3D; 1$, FF’s output is forced to 0<br>Synchronous vs. asynchronous resettable Flip Flop<br>    Asynchronous: resets immediately when $Reset &#x3D; 1$<br>    Synchronous: resets at the clock edge only</p><h4 id="J-K-Flip-flop"><a href="#J-K-Flip-flop" class="headerlink" title="J-K Flip-flop"></a>J-K Flip-flop</h4><p>e.g. <strong>Positive edge-triggered JKFF</strong></p><p>At rising edge of clock<br>$J &#x3D; K &#x3D; 0$, Q is unchanged<br>$J &#x3D; K &#x3D; 1$, Q toggles<br>$J &#x3D; 1, K &#x3D; 0$, Q is set to 1<br>$J &#x3D; 0, K &#x3D; 1$, Q is reset to 0<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="图像2024-11-22 16.01" style="zoom:33%;" /></p><p><strong>Characteristic equation:</strong><br>$$<br>Q(t+1)&#x3D; J’K’Q(t) + J’K•0 + JK’•1 + JKQ(t)’<br>&#x3D; J’K’Q(t) + JK’ + JKQ(t)’<br>&#x3D; J’K’Q(t) + JK’Q(t) + JK’Q(t)’ + JKQ(t)’<br>&#x3D; JQ(t)’ + K’Q(t)<br>$$<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.21.jpeg" alt="图像2024-11-22 16.21" style="zoom:33%;" /></p><h4 id="T-Flip-flop"><a href="#T-Flip-flop" class="headerlink" title="T Flip-flop"></a>T Flip-flop</h4><p>T: Toggle<br>$T &#x3D; 0$, a clock edge does not change the output.<br>$T &#x3D; 1$, a clock edge complements the output.<br>Useful for designing binary counters.</p><table><thead><tr><th>$T$</th><th>$Q_{next}$</th><th>$State$</th></tr></thead><tbody><tr><td>0</td><td>$Q$</td><td>no change</td></tr><tr><td>1</td><td>$Q’$</td><td>take $Q$’s complement</td></tr></tbody></table><p><strong>Characteristic equation:</strong><br>$$<br>Q(t+1) &#x3D; T’Q(t) + TQ(t)’&#x3D; T⊕Q(t)<br>$$<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2021.03.jpeg" alt="图像2024-11-22 21.03" style="zoom:33%;" /></p><h3 id="Characteristic-Table"><a href="#Characteristic-Table" class="headerlink" title="Characteristic Table"></a>Characteristic Table</h3><p><strong>Characteristic table</strong>: describe the behavior of a flip-flop based on its input and current state Q(t) just before the rising edge of the clock, and the resulting next state Q(t+1) after the clock transition.<br><img src="https://cdn.jsdelivr.net/gh/KaixunWang/pic_bed/img/%E5%9B%BE%E5%83%8F2024-11-22%2016.01.jpeg" alt="图像2024-11-22 16.01" style="zoom:40%;" /></p><p><strong>Characteristic equation</strong>: derived from the Characteristic table, e.g. $Q_{t+1} &#x3D; D$</p><ol><li>From characteristic table to truth table</li><li>Algebrically or using K-map to get characteristic equation</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FirstPost</title>
      <link href="/2024/11/21/FirstPost/"/>
      <url>/2024/11/21/FirstPost/</url>
      
        <content type="html"><![CDATA[<p>##Hello World</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
